/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Adapters/VegaLiteAdapter.ts":
/*!*****************************************!*\
  !*** ./src/Adapters/VegaLiteAdapter.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VegaLiteAdapter\": () => (/* binding */ VegaLiteAdapter),\n/* harmony export */   \"findScenegraphNodes\": () => (/* binding */ findScenegraphNodes)\n/* harmony export */ });\n/**\r\n * Adapter to deconstruct Vega-Lite visualizations into an {@link OlliVisSpec}\r\n * @param visObject The Vega Scenegraph from the view\r\n * @param helperVisInformation The Vega-Lite Spec that rendered the visualization\r\n * @returns An {@link OlliVisSpec} of the deconstructed Vega-Lite visualization\r\n */\r\nconst VegaLiteAdapter = (visObject, helperVisInformation) => {\r\n    if (visObject.items.some((node) => node.role === 'scope')) {\r\n        return parseMultiView(visObject, helperVisInformation);\r\n    }\r\n    else {\r\n        return parseChart(visObject, helperVisInformation);\r\n    }\r\n};\r\n/**\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns An {@link OlliVisSpec} of the deconstructed Vega-Lite visualization\r\n */\r\nfunction parseMultiView(scenegraph, spec) {\r\n    const filterUniqueNodes = ((nodeArr) => {\r\n        let uniqueNodes = [];\r\n        nodeArr.forEach((node) => {\r\n            if (uniqueNodes.every((un) => JSON.stringify(un) !== JSON.stringify(node))) {\r\n                uniqueNodes.push(node);\r\n            }\r\n        });\r\n        return uniqueNodes;\r\n    });\r\n    const shallowCopyArray = (objToCopy, arrToPush) => {\r\n        objToCopy.forEach((obj) => {\r\n            const objCopy = Object.assign({}, obj);\r\n            objCopy.data = JSON.parse(JSON.stringify(obj.data));\r\n            arrToPush.push(objCopy);\r\n        });\r\n    };\r\n    let axes = filterUniqueNodes(findScenegraphNodes(scenegraph, \"axis\").map((axis) => parseAxis(scenegraph, axis, spec)));\r\n    let legends = filterUniqueNodes(findScenegraphNodes(scenegraph, \"legend\").map((legend) => parseLegend(scenegraph, legend, spec)));\r\n    let fields = axes.concat(legends).reduce((fieldArr, guide) => fieldArr.concat(guide.field), []);\r\n    let facetedField = spec.encoding.facet !== undefined ? spec.encoding.facet.field : spec.encoding['color'].field;\r\n    let nestedHeirarchies = scenegraph.items.filter((el) => el.role === \"scope\")[0].items\r\n        .map((chart) => {\r\n        let chartData = parseChart(chart, spec);\r\n        shallowCopyArray(axes, chartData.axes);\r\n        shallowCopyArray(legends, chartData.legends);\r\n        chartData.facetedValue = chart.datum[facetedField];\r\n        modifyVisFromMark(chartData, chartData.markUsed, spec);\r\n        return chartData;\r\n    });\r\n    let node = {\r\n        description: \"\",\r\n        data: getVisualizationData(scenegraph, spec),\r\n        dataFieldsUsed: fields,\r\n        charts: nestedHeirarchies,\r\n        facetedField: facetedField\r\n    };\r\n    node.dataFieldsUsed.push(facetedField);\r\n    node.charts.forEach((chart) => {\r\n        chart.data = chart.data.filter((val) => val[facetedField] === chart.title);\r\n    });\r\n    constructChartDescription(node, spec);\r\n    return node;\r\n}\r\n/**\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns An {@link OlliVisSpec} of the deconstructed Vega-Lite visualization\r\n */\r\nfunction parseChart(scenegraph, spec) {\r\n    let axes = findScenegraphNodes(scenegraph, \"axis\").map((axis) => parseAxis(scenegraph, axis, spec));\r\n    let legends = findScenegraphNodes(scenegraph, \"legend\").map((legend) => parseLegend(scenegraph, legend, spec));\r\n    let fields = axes.concat(legends).reduce((fieldArr, guide) => fieldArr.concat(guide.field), []);\r\n    let mark = spec.mark;\r\n    let node = {\r\n        axes: axes.filter((axis) => axis.field !== undefined),\r\n        legends: legends,\r\n        description: \"\",\r\n        dataFieldsUsed: fields,\r\n        gridNodes: [],\r\n        data: getVisualizationData(scenegraph, spec),\r\n        markUsed: mark\r\n    };\r\n    constructChartDescription(node, spec);\r\n    modifyVisFromMark(node, mark, spec);\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param axisScenegraphNode The specific scenegraph node of an axis\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns A {@link Axis} from the converted axisScenegraphNode\r\n */\r\nfunction parseAxis(scenegraph, axisScenegraphNode, spec) {\r\n    const axisView = axisScenegraphNode.items[0];\r\n    const orient = axisView.orient;\r\n    const encodingKey = orient === 'bottom' ? 'x' : 'y';\r\n    const ticks = axisView.items.find((n) => n.role === 'axis-tick').items.map((n) => n.datum.value);\r\n    const title = spec.encoding[encodingKey].title;\r\n    const scale = axisView.datum.scale;\r\n    const axisData = getVisualizationData(scenegraph, spec);\r\n    const axisStr = axisView.orient === \"bottom\" || axisView.orient === \"top\" ? \"X-Axis\" : \"Y-Axis\";\r\n    let field;\r\n    if (spec.encoding[encodingKey].aggregate) {\r\n        field = Object.keys(axisData[0]).filter((key) => key.includes(spec.encoding[encodingKey].field));\r\n    }\r\n    else {\r\n        field = spec.encoding[encodingKey].field;\r\n    }\r\n    return {\r\n        values: ticks,\r\n        title: title === undefined ? axisStr : `${axisStr} titled '${title}'`,\r\n        data: axisData,\r\n        field: field,\r\n        scaleType: spec.encoding[encodingKey].type,\r\n        orient: orient,\r\n        markUsed: spec.mark\r\n    };\r\n}\r\n/**\r\n *\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param legendScenegraphNode The specific scenegraph node of a legend\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns A {@link legend} from the converted legendScenegraphNode\r\n */\r\nfunction parseLegend(scenegraph, legendScenegraphNode, spec) {\r\n    let scale = legendScenegraphNode.items[0].datum.scales[Object.keys(legendScenegraphNode.items[0].datum.scales)[0]];\r\n    let data = getVisualizationData(scenegraph, spec);\r\n    let labels = legendScenegraphNode.items[0].items.find((n) => n.role === \"legend-entry\").items[0].items[0].items;\r\n    return {\r\n        values: labels.map((n) => n.items.find((el) => el.role === \"legend-label\").items[0].datum.value),\r\n        title: spec.encoding['color'].title ? spec.encoding['color'].title : spec.encoding['color'].field,\r\n        data: data,\r\n        field: spec.encoding['color'].field,\r\n        scaleType: spec.scales?.find((specScale) => specScale.name === scale)?.type,\r\n        type: spec.encoding['color'].type,\r\n        markUsed: spec.mark\r\n    };\r\n}\r\n/**\r\n *\r\n * @param node The {@link OlliVisSpec} whose description is being modified\r\n * @param spec The specification of the Vega-Lite visualization being deconstructed\r\n */\r\nfunction constructChartDescription(node, spec) {\r\n    let desc = spec.description ? spec.description : \"\";\r\n    if (node.charts !== undefined) {\r\n        desc = `${desc} with ${node.charts.length} nested charts.`;\r\n        node.description = spec.description;\r\n    }\r\n    else {\r\n        node.description = `${desc}`;\r\n    }\r\n}\r\n/**\r\n * A Map of data used in the visualization\r\n * @param view The Vega Scenegraph of this visualization\r\n * @param spec The Vega-Lite specification for the visualization\r\n * @returns A key-value pair of the data defined in this visualization\r\n */\r\nfunction getVisualizationData(view, spec) {\r\n    try {\r\n        // TODO fix hardcoded dataset name\r\n        const source_0 = view.context.data['source_0'].values.value;\r\n        // let data: Map<string, any[]> = new Map()\r\n        // Object.keys(view.context.data).forEach((key: string) => {\r\n        //     data.set(key, view.context.data[key].values.value)\r\n        // })\r\n        // return data\r\n        return source_0;\r\n    }\r\n    catch (error) {\r\n        throw new Error(`No data defined in the Spec \\n ${error}`);\r\n    }\r\n}\r\n/**\r\n * Traverses a provided scenegraph node for nodes of a specific role.\r\n * @param scenegraphNode The root scenegraph node to traverse\r\n * @param passRole The string of the node role to search for\r\n * @returns an array of ndoes that contain the specified role\r\n */\r\nfunction findScenegraphNodes(scenegraphNode, passRole) {\r\n    let nodes = [];\r\n    const cancelRoles = [\"cell\", \"axis-grid\"];\r\n    if (scenegraphNode.items === undefined) {\r\n        return nodes;\r\n    }\r\n    scenegraphNode.items.forEach((nestedItem) => {\r\n        if (nestedItem.role !== undefined) {\r\n            if (nestedItem.role === passRole && verifyNode(nestedItem, cancelRoles)) {\r\n                nodes.push(nestedItem);\r\n            }\r\n            else {\r\n                nodes = nodes.concat(findScenegraphNodes(nestedItem, passRole));\r\n            }\r\n        }\r\n        else {\r\n            nodes = nodes.concat(findScenegraphNodes(nestedItem, passRole));\r\n        }\r\n    });\r\n    return nodes;\r\n}\r\n/**\r\n * Checks if a scenegraph node or its children do not have any specified role names\r\n * @param scenegraphNode The scenegraph ndoe to traverse\r\n * @param cancelRoles Roles of Scenegraph Nodes that should not be parsed\r\n * @returns True if the provided scenegraph node and its children do not contain any of the cancelRols\r\n */\r\nfunction verifyNode(scenegraphNode, cancelRoles) {\r\n    if (scenegraphNode.role !== undefined && !cancelRoles.some((role) => scenegraphNode.role.includes(role))) {\r\n        if (scenegraphNode.items.every((item) => verifyNode(item, cancelRoles)) || scenegraphNode.items === undefined) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else if (scenegraphNode.role === undefined && scenegraphNode.items !== undefined) {\r\n        return scenegraphNode.items.every((item) => verifyNode(item, cancelRoles));\r\n    }\r\n    else if (scenegraphNode.role === undefined && scenegraphNode.items === undefined) {\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n *\r\n * @param vis The {@link ChartInformation} to update\r\n * @param mark The {@link Mark} used in the provided {@Link ChartInformation}\r\n * @param spec The Vega-Lite specification of the provided visualization\r\n */\r\nfunction modifyVisFromMark(vis, mark, spec) {\r\n    switch (mark) {\r\n        case 'bar':\r\n            const nomAxis = Object.keys(spec.encoding).filter((key) => {\r\n                return spec.encoding[key].type === \"nominal\" || spec.encoding[key].aggregate === undefined;\r\n            })[0];\r\n            vis.axes = vis.axes.filter((visAxis) => visAxis.title.toLowerCase().includes(`${nomAxis}-axis`));\r\n            break;\r\n        case 'geoshape':\r\n            break;\r\n        case 'point':\r\n            if (vis.title) {\r\n                vis.title = `Scatter plot with title ${vis.title} `;\r\n            }\r\n            vis.gridNodes = [...vis.axes];\r\n            break;\r\n    }\r\n}\r\nwindow.VegaLiteAdapter = VegaLiteAdapter;\r\n\n\n//# sourceURL=webpack://olli/./src/Adapters/VegaLiteAdapter.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/Adapters/VegaLiteAdapter.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;