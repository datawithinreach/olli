/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Adapters/Types.ts":
/*!*******************************!*\
  !*** ./src/Adapters/Types.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isChart\": () => (/* binding */ isChart),\n/* harmony export */   \"isFacetedChart\": () => (/* binding */ isFacetedChart)\n/* harmony export */ });\nconst isChart = (olliVisSpec) => {\r\n    return Boolean(olliVisSpec.axes && olliVisSpec.legends);\r\n};\r\nconst isFacetedChart = (olliVisSpec) => {\r\n    return Boolean(olliVisSpec.facetedField);\r\n};\r\n\n\n//# sourceURL=webpack://olli/./src/Adapters/Types.ts?");

/***/ }),

/***/ "./src/Render/Table/index.ts":
/*!***********************************!*\
  !*** ./src/Render/Table/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderTable\": () => (/* binding */ renderTable)\n/* harmony export */ });\n/**\r\n *\r\n * @param tree The {@link AccessibilityTreeNode} to generate a table from\r\n * @returns An {@link HTMLElement} table of the data used in a visualization\r\n */\r\nfunction renderTable(tree) {\r\n    const table = document.createElement(\"table\");\r\n    const tableBody = document.createElement(\"tbody\");\r\n    const tableHeaders = document.createElement(\"tr\");\r\n    tree.fieldsUsed.forEach((field) => {\r\n        const header = document.createElement(\"th\");\r\n        header.innerText = field;\r\n        tableHeaders.appendChild(header);\r\n    });\r\n    tableBody.appendChild(tableHeaders);\r\n    tree.selected.forEach((data) => {\r\n        const dataRow = document.createElement(\"tr\");\r\n        tree.fieldsUsed.forEach((field) => {\r\n            const tableData = document.createElement(\"td\");\r\n            tableData.innerText = data[field];\r\n            dataRow.appendChild(tableData);\r\n        });\r\n        tableBody.appendChild(dataRow);\r\n    });\r\n    table.appendChild(tableBody);\r\n    return table;\r\n}\r\n\n\n//# sourceURL=webpack://olli/./src/Render/Table/index.ts?");

/***/ }),

/***/ "./src/Render/TreeView/TreeItemLinks.ts":
/*!**********************************************!*\
  !*** ./src/Render/TreeView/TreeItemLinks.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GridTreeItemLink\": () => (/* binding */ GridTreeItemLink),\n/* harmony export */   \"TreeItemLink\": () => (/* binding */ TreeItemLink)\n/* harmony export */ });\n/*\r\n*   This content is licensed according to the W3C Software License at\r\n*   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n*\r\n*   File:   TreeItemLink.js\r\n*\r\n*   Desc:   Treeitem widget that implements ARIA Authoring Practices\r\n*           for a tree being used as a file viewer\r\n*/\r\n/*\r\n*   @constructor\r\n*\r\n*   @desc\r\n*       Treeitem object for representing the state and user interactions for a\r\n*       treeItem widget\r\n*\r\n*   @param node\r\n*       An element with the role=tree attribute\r\n*/\r\nclass TreeItemLink {\r\n    tree;\r\n    level;\r\n    parent;\r\n    children;\r\n    domNode;\r\n    label;\r\n    stopDefaultClick;\r\n    isExpandable;\r\n    isVisible;\r\n    inGroup;\r\n    lastVisitedChild;\r\n    keyCode;\r\n    constructor(node, treeObj, group, level) {\r\n        node.tabIndex = -1;\r\n        this.tree = treeObj;\r\n        this.parent = group;\r\n        this.domNode = node;\r\n        this.label = node.textContent.trim();\r\n        this.stopDefaultClick = false;\r\n        this.level = level;\r\n        this.children = [];\r\n        this.lastVisitedChild = null;\r\n        // Check whether node is a DOM element\r\n        if (typeof node !== 'object') {\r\n            return;\r\n        }\r\n        if (node.getAttribute('aria-label')) {\r\n            this.label = node.getAttribute('aria-label').trim();\r\n        }\r\n        this.isExpandable = false;\r\n        this.isVisible = false;\r\n        this.inGroup = false;\r\n        if (group) {\r\n            this.inGroup = true;\r\n        }\r\n        let elem = node.firstElementChild;\r\n        while (elem) {\r\n            if (elem.tagName.toLowerCase() == 'ul') {\r\n                elem.setAttribute('role', 'group');\r\n                this.isExpandable = true;\r\n                break;\r\n            }\r\n            elem = elem.nextElementSibling;\r\n        }\r\n        this.keyCode = Object.freeze({\r\n            RETURN: 13,\r\n            SPACE: 32,\r\n            PAGEUP: 33,\r\n            PAGEDOWN: 34,\r\n            END: 35,\r\n            HOME: 36,\r\n            LEFT: 37,\r\n            UP: 38,\r\n            RIGHT: 39,\r\n            DOWN: 40,\r\n            X: 88,\r\n            Y: 89,\r\n            L: 76,\r\n            G: 71,\r\n            W: 87,\r\n            A: 65,\r\n            S: 83,\r\n            D: 68,\r\n            ESCAPE: 27,\r\n            PLUS: 107,\r\n            MINUS: 189\r\n        });\r\n    }\r\n    init() {\r\n        this.domNode.tabIndex = -1;\r\n        if (!this.domNode.getAttribute('role')) {\r\n            this.domNode.setAttribute('role', 'treeitem');\r\n        }\r\n        this.domNode.addEventListener('keydown', this.handleKeydown.bind(this));\r\n        this.domNode.addEventListener('click', this.handleClick.bind(this));\r\n        this.domNode.addEventListener('focus', this.handleFocus.bind(this));\r\n        this.domNode.addEventListener('blur', this.handleBlur.bind(this));\r\n        if (this.isExpandable) {\r\n            this.domNode.firstElementChild.addEventListener('mouseover', this.handleMouseOver.bind(this));\r\n            this.domNode.firstElementChild.addEventListener('mouseout', this.handleMouseOut.bind(this));\r\n        }\r\n        else {\r\n            this.domNode.addEventListener('mouseover', this.handleMouseOver.bind(this));\r\n            this.domNode.addEventListener('mouseout', this.handleMouseOut.bind(this));\r\n        }\r\n    }\r\n    isExpanded() {\r\n        if (this.isExpandable) {\r\n            return this.domNode.getAttribute('aria-expanded') === 'true';\r\n        }\r\n        return false;\r\n    }\r\n    /* EVENT HANDLERS */\r\n    handleKeydown(event) {\r\n        this.stopDefaultClick = false;\r\n        if (event.altKey || event.ctrlKey || event.metaKey) {\r\n            return;\r\n        }\r\n        if (event.shiftKey) {\r\n            let root = this.getRootNode();\r\n            if (event.keyCode == this.keyCode.SPACE || event.keyCode == this.keyCode.RETURN) {\r\n                event.stopPropagation();\r\n                this.stopDefaultClick = true;\r\n            }\r\n            else if (root.label.includes('nested charts') && event.target === this.domNode) {\r\n                const nodePosition = (item) => {\r\n                    let arr = [];\r\n                    let node = item;\r\n                    while (node !== undefined) {\r\n                        if (node.parent) {\r\n                            let index = node.parent.children.indexOf(node);\r\n                            if (index !== -1) {\r\n                                arr.push(index);\r\n                            }\r\n                        }\r\n                        node = node.parent;\r\n                    }\r\n                    return arr;\r\n                };\r\n                if (event.keyCode === this.keyCode.LEFT) {\r\n                    let pos = nodePosition(this).reverse();\r\n                    pos[0] = pos[0] - 1;\r\n                    if (pos[0] >= 0) {\r\n                        this.shiftToNode(pos);\r\n                    }\r\n                }\r\n                else if (event.keyCode === this.keyCode.RIGHT) {\r\n                    let pos = nodePosition(this).reverse();\r\n                    pos[0] = pos[0] + 1;\r\n                    if (pos[pos.length - 1] < root.children.length) {\r\n                        this.shiftToNode(pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.checkBaseKeys(event);\r\n        }\r\n    }\r\n    checkBaseKeys(event) {\r\n        let flag = false;\r\n        switch (event.keyCode) {\r\n            case this.keyCode.SPACE:\r\n            case this.keyCode.RETURN:\r\n                if (this.isExpandable) {\r\n                    if (this.isExpanded()) {\r\n                        this.tree.collapseTreeitem(this);\r\n                    }\r\n                    else {\r\n                        this.tree.expandTreeitem(this);\r\n                    }\r\n                    flag = true;\r\n                }\r\n                else {\r\n                    event.stopPropagation();\r\n                    this.stopDefaultClick = true;\r\n                }\r\n                break;\r\n            case this.keyCode.DOWN:\r\n                if (this.children.length > 0) {\r\n                    if (this.isExpandable)\r\n                        this.tree.expandTreeitem(this);\r\n                    this.tree.setFocusToNextLaver();\r\n                }\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.LEFT:\r\n                this.tree.setFocusToPreviousItem();\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.RIGHT:\r\n                this.tree.setFocusToNextItem();\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.ESCAPE:\r\n            case this.keyCode.UP:\r\n                if (this.isExpandable && this.isExpanded()) {\r\n                    this.tree.setFocusToParentItem();\r\n                    this.tree.collapseTreeitem(this);\r\n                    flag = true;\r\n                }\r\n                else {\r\n                    if (this.inGroup) {\r\n                        this.tree.setFocusToParentItem();\r\n                        flag = true;\r\n                    }\r\n                }\r\n                break;\r\n            case this.keyCode.HOME:\r\n                this.tree.setFocusToItem(this.parent.children[0]);\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.END:\r\n                this.tree.setFocusToItem(this.parent.children[this.parent.children.length - 1]);\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.X:\r\n                // this.tree.focusOnSpecificNode(\"x-axis\", this)\r\n                break;\r\n            case this.keyCode.Y:\r\n                // this.tree.focusOnSpecificNode(\"y-axis\", this)\r\n                break;\r\n            case this.keyCode.L:\r\n                // this.tree.focusOnSpecificNode(\"legend\", this)\r\n                break;\r\n        }\r\n        if (flag) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n    }\r\n    handleClick(event) {\r\n        // only process click events that directly happened on this treeitem\r\n        if (event.target !== this.domNode && event.target !== this.domNode.firstElementChild) {\r\n            return;\r\n        }\r\n        if (this.isExpandable) {\r\n            if (this.isExpanded()) {\r\n                this.tree.setFocusToItem(this);\r\n                this.tree.collapseTreeitem(this);\r\n            }\r\n            else {\r\n                if (this.isExpandable && !this.isExpanded()) {\r\n                    this.tree.expandTreeitem(this);\r\n                    this.tree.setFocusToItem(this);\r\n                }\r\n                this.tree.setFocusToNextLaver();\r\n            }\r\n            event.stopPropagation();\r\n        }\r\n    }\r\n    handleFocus(event) {\r\n        let node = this.domNode;\r\n        if (this.isExpandable) {\r\n            node = node.firstElementChild;\r\n        }\r\n        node.classList.add('focus');\r\n    }\r\n    handleBlur(event) {\r\n        let node = this.domNode;\r\n        if (this.isExpandable) {\r\n            node = node.firstElementChild;\r\n        }\r\n        node.classList.remove('focus');\r\n    }\r\n    handleMouseOver(event) {\r\n        event.currentTarget.classList.add('hover');\r\n    }\r\n    handleMouseOut(event) {\r\n        event.currentTarget.classList.remove('hover');\r\n    }\r\n    getRootNode() {\r\n        if (this.parent !== undefined) {\r\n            return this.parent.getRootNode();\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    }\r\n    shiftToNode(pos) {\r\n        let node = pos.reduce((nodeToReturn, posNum, i) => {\r\n            if (nodeToReturn.children[posNum] === undefined) {\r\n                return nodeToReturn;\r\n            }\r\n            else {\r\n                return nodeToReturn.children[posNum];\r\n            }\r\n        }, this.getRootNode());\r\n        this.tree.setFocusToAdjacentItem(node);\r\n    }\r\n}\r\nclass GridTreeItemLink extends TreeItemLink {\r\n    gridIndex;\r\n    gridWidth;\r\n    rowPosition;\r\n    constructor(node, treeObj, group, level) {\r\n        super(node, treeObj, group, level);\r\n        const getNodeFromString = (partialLabelString) => {\r\n            return this.parent.parent.children.reduce((returnVal, currentNode) => {\r\n                if (currentNode.label.includes(partialLabelString)) {\r\n                    return currentNode;\r\n                }\r\n                else {\r\n                    return returnVal;\r\n                }\r\n            });\r\n        };\r\n        this.gridIndex = this.parent.children.length;\r\n        this.gridWidth = this.parent.parent.label.includes('facet') ? getNodeFromString(\"Y-Axis\").children.length : getNodeFromString(\"X-Axis\").children.length;\r\n        const getRowPosition = () => {\r\n            if (this.gridIndex !== 0) {\r\n                let prevPosition = this.parent.children[this.gridIndex - 1].rowPosition;\r\n                return prevPosition === this.gridWidth ? 1 : prevPosition + 1;\r\n            }\r\n            else {\r\n                return 1;\r\n            }\r\n        };\r\n        this.rowPosition = getRowPosition();\r\n    }\r\n    handleKeydown(event) {\r\n        super.handleKeydown(event);\r\n        let currentChildIndex = this.parent.children.indexOf(this);\r\n        switch (event.keyCode) {\r\n            case this.keyCode.W:\r\n                if (currentChildIndex + this.gridWidth < this.parent.children.length) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex + this.gridWidth]);\r\n                }\r\n                break;\r\n            case this.keyCode.S:\r\n                if (currentChildIndex - this.gridWidth >= 0) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex - this.gridWidth]);\r\n                }\r\n                break;\r\n            case this.keyCode.A:\r\n                if (this.rowPosition > 1) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex - 1]);\r\n                }\r\n                break;\r\n            case this.keyCode.D:\r\n                if (this.rowPosition < this.gridWidth) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex + 1]);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://olli/./src/Render/TreeView/TreeItemLinks.ts?");

/***/ }),

/***/ "./src/Render/TreeView/TreeLink.ts":
/*!*****************************************!*\
  !*** ./src/Render/TreeView/TreeLink.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TreeLinks\": () => (/* binding */ TreeLinks)\n/* harmony export */ });\n/* harmony import */ var _TreeItemLinks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeItemLinks */ \"./src/Render/TreeView/TreeItemLinks.ts\");\n\r\n/*\r\n*   This content is licensed according to the W3C Software License at\r\n*   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n*\r\n*   File:   TreeLinks.ts\r\n*\r\n*   Desc:   Tree widget that implements ARIA Authoring Practices\r\n*           for a tree being used as a file viewer\r\n*/\r\n/*\r\n*   @constructor\r\n*\r\n*   @desc\r\n*       Tree item object for representing the state and user interactions for a\r\n*       tree widget\r\n*\r\n*   @param node\r\n*       An element with the role=tree attribute\r\n*/\r\nclass TreeLinks {\r\n    domNode;\r\n    treeitems;\r\n    firstTreeitem;\r\n    lastTreeitem;\r\n    currentNode;\r\n    constructor(node) {\r\n        // Check whether node is a DOM element\r\n        if (typeof node !== 'object') {\r\n            return;\r\n        }\r\n        this.domNode = node;\r\n        this.treeitems = [];\r\n    }\r\n    init() {\r\n        function findTreeitems(node, tree, group, treeLevel) {\r\n            let elem = node.firstElementChild;\r\n            let ti = group;\r\n            while (elem) {\r\n                if ((elem.tagName.toLowerCase() === 'li' && elem.firstElementChild.tagName.toLowerCase() === 'span') ||\r\n                    elem.tagName.toLowerCase() === `tr` || (elem.tagName.toLowerCase() === 'th') || (elem.tagName.toLowerCase() === 'td')) {\r\n                    if (group && group.label.substring(0, 9) === \"Grid view\") {\r\n                        ti = new _TreeItemLinks__WEBPACK_IMPORTED_MODULE_0__.GridTreeItemLink(elem, tree, group, treeLevel);\r\n                    }\r\n                    else {\r\n                        ti = new _TreeItemLinks__WEBPACK_IMPORTED_MODULE_0__.TreeItemLink(elem, tree, group, treeLevel);\r\n                    }\r\n                    ti.init();\r\n                    if (group)\r\n                        group.children.push(ti);\r\n                    tree.treeitems.push(ti);\r\n                }\r\n                if (elem.firstElementChild) {\r\n                    findTreeitems(elem, tree, ti, treeLevel + 1);\r\n                }\r\n                elem = elem.nextElementSibling;\r\n            }\r\n        }\r\n        // initialize pop up menus\r\n        if (!this.domNode.getAttribute('role')) {\r\n            this.domNode.setAttribute('role', 'tree');\r\n        }\r\n        findTreeitems(this.domNode, this, undefined, 0);\r\n        this.updateVisibleTreeitems();\r\n        this.firstTreeitem.domNode.tabIndex = 0;\r\n        this.currentNode = this.firstTreeitem;\r\n    }\r\n    setFocusToItem(treeitem) {\r\n        this.currentNode.domNode.tabIndex = 0;\r\n        this.currentNode = treeitem;\r\n        this.currentNode.domNode.focus();\r\n    }\r\n    setFocusToAdjacentItem(treeitem) {\r\n        this.currentNode.domNode.tabIndex = 0;\r\n        let parent = this.currentNode.parent;\r\n        while (parent !== undefined) {\r\n            parent.domNode.setAttribute('aria-expanded', false);\r\n            this.updateVisibleTreeitems();\r\n            parent = parent.parent;\r\n        }\r\n        if (!treeitem.isVisible) {\r\n            let node = treeitem;\r\n            while (!treeitem.isVisible) {\r\n                this.expandTreeitem(node.parent);\r\n                node = node.parent;\r\n            }\r\n        }\r\n        this.currentNode = treeitem;\r\n        this.currentNode.domNode.focus();\r\n    }\r\n    setFocusToNextItem() {\r\n        if (this.currentNode.parent) {\r\n            let nodeIndex = this.currentNode.parent.children.indexOf(this.currentNode);\r\n            if (nodeIndex < this.currentNode.parent.children.length - 1) {\r\n                this.setFocusToItem(this.currentNode.parent.children[nodeIndex + 1]);\r\n            }\r\n        }\r\n    }\r\n    setFocusToNextLaver() {\r\n        if (this.currentNode.lastVisitedChild !== null) {\r\n            this.setFocusToItem(this.currentNode.lastVisitedChild);\r\n        }\r\n        else {\r\n            this.setFocusToItem(this.currentNode.children[0]);\r\n        }\r\n    }\r\n    setFocusToPreviousItem() {\r\n        if (this.currentNode.parent) {\r\n            let nodeIndex = this.currentNode.parent.children.indexOf(this.currentNode);\r\n            if (nodeIndex > 0) {\r\n                this.setFocusToItem(this.currentNode.parent.children[nodeIndex - 1]);\r\n            }\r\n        }\r\n    }\r\n    setFocusToParentItem() {\r\n        if (this.currentNode.parent) {\r\n            this.currentNode.parent.lastVisitedChild = this.currentNode;\r\n            this.setFocusToItem(this.currentNode.parent);\r\n            if (this.currentNode.isExpandable && this.currentNode.isExpanded())\r\n                this.collapseTreeitem(this.currentNode);\r\n        }\r\n    }\r\n    setFocusToFirstItem() {\r\n        this.setFocusToItem(this.firstTreeitem);\r\n    }\r\n    setFocusToLastItem() {\r\n        this.setFocusToItem(this.lastTreeitem);\r\n    }\r\n    expandTreeitem(currentItem) {\r\n        if (currentItem.isExpandable) {\r\n            currentItem.domNode.setAttribute('aria-expanded', true);\r\n            this.updateVisibleTreeitems();\r\n        }\r\n    }\r\n    expandAllSiblingItems(currentItem) {\r\n        for (let i = 0; i < this.treeitems.length; i++) {\r\n            let ti = this.treeitems[i];\r\n            if ((ti.parent === currentItem.parent) && ti.isExpandable) {\r\n                this.expandTreeitem(ti);\r\n            }\r\n        }\r\n    }\r\n    collapseTreeitem(item) {\r\n        let parent;\r\n        if (item.isExpanded()) {\r\n            parent = this.currentNode;\r\n        }\r\n        else {\r\n            parent = this.currentNode.parent;\r\n        }\r\n        if (parent) {\r\n            parent.domNode.setAttribute('aria-expanded', false);\r\n            this.updateVisibleTreeitems();\r\n            this.setFocusToItem(parent);\r\n        }\r\n    }\r\n    updateVisibleTreeitems() {\r\n        this.firstTreeitem = this.treeitems[0];\r\n        for (let i = 0; i < this.treeitems.length; i++) {\r\n            let ti = this.treeitems[i];\r\n            let parent = ti.domNode.parentNode;\r\n            ti.isVisible = true;\r\n            while (parent && (parent !== this.domNode)) {\r\n                if (parent.getAttribute('aria-expanded') == 'false') {\r\n                    ti.isVisible = false;\r\n                }\r\n                parent = parent.parentNode;\r\n            }\r\n            if (ti.isVisible) {\r\n                this.lastTreeitem = ti;\r\n            }\r\n        }\r\n    }\r\n    focusOnSpecificNode(searchStr, base, visitedNodes) {\r\n        let visited = visitedNodes ? visitedNodes : [];\r\n        if (!visited.includes(base)) {\r\n            visited.push(base);\r\n            if (base.label.split(\" \")[0].toLowerCase() === searchStr) {\r\n                const expandParents = (node) => {\r\n                    if (node) {\r\n                        if (!node.isExpanded()) {\r\n                            this.expandTreeitem(node);\r\n                            expandParents(node.parent);\r\n                        }\r\n                    }\r\n                };\r\n                const collapseChildren = (node) => {\r\n                    if (base !== node) {\r\n                        node.parent.lastVisitedChild = node;\r\n                        this.currentNode = node.parent;\r\n                        this.collapseTreeitem(this.currentNode);\r\n                    }\r\n                };\r\n                expandParents(base.parent);\r\n                if (base.isExpanded()) {\r\n                    collapseChildren(this.currentNode);\r\n                    base.lastVisitedChild = this.currentNode;\r\n                    this.collapseTreeitem(this.currentNode);\r\n                }\r\n                this.setFocusToItem(base);\r\n            }\r\n            else {\r\n                if (base.parent) {\r\n                    this.focusOnSpecificNode(searchStr, base.parent, visited);\r\n                }\r\n                base.children.forEach((child) => {\r\n                    return this.focusOnSpecificNode(searchStr, child, visited);\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://olli/./src/Render/TreeView/TreeLink.ts?");

/***/ }),

/***/ "./src/Render/TreeView/TreeStyle.ts":
/*!******************************************!*\
  !*** ./src/Render/TreeView/TreeStyle.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"treeStyle\": () => (/* binding */ treeStyle)\n/* harmony export */ });\nconst treeStyle = `ul[role=\"tree\"] {\r\n    margin: 0;\r\n    padding: 0;\r\n    list-style: none;\r\n  }\r\n  \r\n  ul[role=\"tree\"] li {\r\n    margin: 0;\r\n    padding: 0;\r\n    list-style: none;\r\n  }\r\n  \r\n  ul[role=\"tree\"] a {\r\n    text-decoration: underline;\r\n    border-color: transparent;\r\n  }\r\n  \r\n  [role=\"treeitem\"] ul {\r\n    margin: 0;\r\n    padding: 0;\r\n    margin-left: 0.9em;\r\n  }\r\n  \r\n  [role=\"treeitem\"][aria-expanded=\"false\"] > ul {\r\n    display: none;\r\n  }\r\n  \r\n  [role=\"treeitem\"][aria-expanded=\"true\"] > ul {\r\n    display: block;\r\n  }\r\n  \r\n  [role=\"treeitem\"][aria-expanded=\"false\"] > span::before {\r\n    position: relative;\r\n    left: -0.25em;\r\n  }\r\n  \r\n  [role=\"treeitem\"][aria-expanded=\"true\"] > span::before {\r\n    position: relative;\r\n    left: -0.25em;\r\n  }\r\n  \r\n  /* [role=\"treeitem\"], */\r\n  [role=\"treeitem\"] span {\r\n    width: 16em;\r\n    margin: 0;\r\n    padding: 0.125em;\r\n    border: 2px transparent solid;\r\n    display: block;\r\n  }\r\n  \r\n  /* disable default keyboard focus styling for treeitems\r\n     Keyboard focus is styled with the following CSS */\r\n  [role=\"treeitem\"]:focus {\r\n    outline: 0;\r\n  }\r\n  \r\n  [role=\"treeitem\"].focus,\r\n  [role=\"treeitem\"] span.focus {\r\n    border-color: black;\r\n    background-color: #ddd;\r\n  }\r\n  \r\n  [role=\"treeitem\"].hover,\r\n  [role=\"treeitem\"] span.hover {\r\n    background-color: #ddd;\r\n  }`;\r\n\n\n//# sourceURL=webpack://olli/./src/Render/TreeView/TreeStyle.ts?");

/***/ }),

/***/ "./src/Render/TreeView/index.ts":
/*!**************************************!*\
  !*** ./src/Render/TreeView/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderTree\": () => (/* binding */ renderTree)\n/* harmony export */ });\n/* harmony import */ var _TreeStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeStyle */ \"./src/Render/TreeView/TreeStyle.ts\");\n\r\n/**\r\n *\r\n * @param tree A {@link AccessibilityTreeNode} to generate a navigable tree view from\r\n * @returns An {@link HTMLElement} ARIA TreeView of the navigable tree view for a visualization\r\n */\r\nfunction renderTree(tree) {\r\n    let nodeToAppend = document.createElement(\"li\");\r\n    nodeToAppend.setAttribute(\"role\", \"treeitem\");\r\n    nodeToAppend.setAttribute(\"aria-expanded\", \"false\");\r\n    const nestedChildElements = document.createElement(\"ul\");\r\n    const nodeDescription = document.createElement(\"span\");\r\n    nodeDescription.appendChild(document.createTextNode(tree.description));\r\n    const treeChildren = tree.children;\r\n    const dataChildren = treeChildren.filter((child) => child.type === \"data\");\r\n    if (dataChildren.length > 0) {\r\n        const table = document.createElement(\"table\");\r\n        const tableBody = document.createElement(\"tbody\");\r\n        const rowHeaders = document.createElement(\"tr\");\r\n        tree.fieldsUsed.forEach((key) => {\r\n            const header = document.createElement(\"th\");\r\n            header.setAttribute(\"class\", \"tableInformation\");\r\n            header.innerText = key;\r\n            rowHeaders.appendChild(header);\r\n        });\r\n        tableBody.appendChild(rowHeaders);\r\n        dataChildren.forEach((dataPoint) => {\r\n            const dataRow = document.createElement(\"tr\");\r\n            tree.fieldsUsed.forEach((key) => {\r\n                const headerData = document.createElement(\"td\");\r\n                headerData.setAttribute(\"class\", \"tableInformation\");\r\n                const value = dataPoint.selected[0][key];\r\n                if (!isNaN(value) && value % 1 != 0) {\r\n                    headerData.innerText = Number(value).toFixed(2);\r\n                }\r\n                else {\r\n                    headerData.innerText = dataPoint.selected[0][key];\r\n                }\r\n                dataRow.appendChild(headerData);\r\n            });\r\n            tableBody.appendChild(dataRow);\r\n        });\r\n        table.appendChild(tableBody);\r\n        nestedChildElements.appendChild(table);\r\n    }\r\n    nodeToAppend.appendChild(nodeDescription);\r\n    if (treeChildren.length > 0) {\r\n        treeChildren.filter((child) => child.type !== `data`).forEach((child) => {\r\n            nestedChildElements.appendChild(renderTree(child));\r\n        });\r\n        nodeToAppend.appendChild(nestedChildElements);\r\n    }\r\n    const style = document.createElement('style');\r\n    style.innerHTML = _TreeStyle__WEBPACK_IMPORTED_MODULE_0__.treeStyle;\r\n    document.head.appendChild(style);\r\n    return nodeToAppend;\r\n}\r\n\n\n//# sourceURL=webpack://olli/./src/Render/TreeView/index.ts?");

/***/ }),

/***/ "./src/Structure/index.ts":
/*!********************************!*\
  !*** ./src/Structure/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"olliVisSpecToTree\": () => (/* binding */ olliVisSpecToTree)\n/* harmony export */ });\n/* harmony import */ var _Adapters_Types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Adapters/Types */ \"./src/Adapters/Types.ts\");\n\r\n/**\r\n * Constructs an {@link AccessibilityTreeNode} based off of a generalized visualization\r\n * @param olliVisSpec the {@link Chart} or {@link FacetedChart} to transform into a tree\r\n * @returns The transormed {@link AccessibilityTreeNode}\r\n */\r\nfunction olliVisSpecToTree(olliVisSpec) {\r\n    let node;\r\n    if ((0,_Adapters_Types__WEBPACK_IMPORTED_MODULE_0__.isFacetedChart)(olliVisSpec)) {\r\n        node = informationToNode(olliVisSpec.description, null, olliVisSpec.data, \"multiView\", olliVisSpec);\r\n        node.description += ` With ${node.children.length} nested charts`;\r\n    }\r\n    else {\r\n        const axesString = olliVisSpec.axes.length > 0 ? ` ${olliVisSpec.axes.length} axes and` : '';\r\n        const legendsString = olliVisSpec.legends.length > 0 ? ` ${olliVisSpec.legends.length} legends` : '';\r\n        node = informationToNode(olliVisSpec.description, null, [], \"chart\", olliVisSpec);\r\n        node.description += ` with ${axesString} ${legendsString}`;\r\n    }\r\n    return node;\r\n}\r\n/**\r\n * Generates children tree nodes for the given parent node.\r\n * @param parent The root faceted chart to be the parent of each nested chart\r\n * @param multiViewChart The {@link FacetedChart} of the abstracted visualization\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateMultiViewChildren(parent, multiViewChart) {\r\n    return multiViewChart.charts.map((singleChart) => informationToNode(`A facet titled ${singleChart.facetedValue}, ${multiViewChart.charts.indexOf(singleChart) + 1} of ${multiViewChart.charts.length}`, parent, [], \"chart\", singleChart));\r\n}\r\n/**\r\n * Recursively generates children nodes of a chart's structured elements for the provided parent\r\n * @param childrenNodes the array of children nodes to eventually return to the parent\r\n * @param parent The root chart to be the parent of each nested chart\r\n * @param axes The {@link Guide}s of axes to be transformed into {@link AccessibilityTreeNode}s\r\n * @param legends The {@link Guide}s of legends to be transformed into {@link AccessibilityTreeNode}s\r\n * @param grids The {@link Guide}s of axes with grid lines to be transformed into {@link AccessibilityTreeNode}s\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateChartChildren(childrenNodes, parent, axes, legends, grids) {\r\n    if (axes.length > 0) {\r\n        const axis = axes.pop();\r\n        const scaleType = axis.scaleType ? `for a ${axis.scaleType} scale ` : \"\";\r\n        const axisField = Array.isArray(axis.field) ? axis.field[1] : axis.field;\r\n        let minValue = axis.data.reduce((currentMin, currentVal) => {\r\n            if (currentVal[axisField] < currentMin) {\r\n                return currentVal[axisField];\r\n            }\r\n            else {\r\n                return currentMin;\r\n            }\r\n        }, axis.data[0][axisField]);\r\n        let maxValue = axis.data.reduce((currentMax, currentVal) => {\r\n            if (currentVal[axisField] > currentMax) {\r\n                return currentVal[axisField];\r\n            }\r\n            else {\r\n                return currentMax;\r\n            }\r\n        }, axis.data[0][axisField]);\r\n        if (axisField.toLowerCase().includes(\"date\")) {\r\n            minValue = new Date(minValue).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' });\r\n            maxValue = new Date(maxValue).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' });\r\n        }\r\n        const description = `${axis.title} ${scaleType}with values from ${minValue} to ${maxValue}`;\r\n        childrenNodes.push(informationToNode(description, parent, axis.data, axis.title.includes(\"Y-Axis\") ? \"yAxis\" : \"xAxis\", axis));\r\n        return generateChartChildren(childrenNodes, parent, axes, legends, grids);\r\n    }\r\n    else if (legends.length > 0) {\r\n        const legend = legends.pop();\r\n        const scaleType = legend.scaleType ? `for ${legend.scaleType} scale ` : \"\";\r\n        let node = informationToNode(legend.title, parent, legend.data, \"legend\", legend);\r\n        node.description = `Legend titled '${node.description}' ${scaleType}with ${node.children.length} values`;\r\n        childrenNodes.push(node);\r\n        return generateChartChildren(childrenNodes, parent, axes, legends, grids);\r\n    }\r\n    else if (grids.length > 0 && grids.length === 2) {\r\n        const grid = [grids.pop(), grids.pop()];\r\n        childrenNodes.push(informationToNode(\"Grid view of the data\", parent, grid[0].data, \"grid\", grid));\r\n        return generateChartChildren(childrenNodes, parent, axes, legends, grids);\r\n    }\r\n    else {\r\n        return childrenNodes;\r\n    }\r\n}\r\n/**\r\n * Generates the incremental children for each structured element of a visualization\r\n * @param parent The structured element whose data is being incrmeented\r\n * @param field The data field used to compare idividual data points\r\n * @param values The groupings or increments of values for the structured element (ex: for axes these are the array of ticks)\r\n * @param data The array of data used in the visualization\r\n * @param markUsed {@link Mark} of the visualization\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateStructuredNodeChildren(parent, field, values, data, markUsed) {\r\n    if (isStringArray(values) || parent.type === \"legend\") {\r\n        return values.map((grouping) => {\r\n            return informationToNode(`${[[grouping]]}`, parent, data.filter((node) => node[field] === grouping), \"filteredData\", data.filter((node) => node[field] === grouping));\r\n        });\r\n    }\r\n    else {\r\n        const filterData = (lowerBound, upperBound) => {\r\n            return data.filter((val) => {\r\n                return val[field] >= lowerBound && val[field] < upperBound;\r\n            });\r\n        };\r\n        let valueIncrements;\r\n        if (markUsed !== 'bar') {\r\n            valueIncrements = values.reduce(getEncodingValueIncrements, []);\r\n        }\r\n        else {\r\n            valueIncrements = values.map((val) => [val, val]);\r\n        }\r\n        return valueIncrements.map((range) => {\r\n            let desc = ``;\r\n            if (parent.description.includes(\"date\") || parent.description.includes(\"temporal\")) {\r\n                range.forEach((val) => desc += `${new Date(val).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' })}, `);\r\n            }\r\n            else {\r\n                desc = `${range},`;\r\n            }\r\n            return informationToNode(desc, parent, filterData(range[0], range[1]), \"filteredData\", filterData(range[0], range[1]));\r\n        });\r\n    }\r\n}\r\n/**\r\n * Generates the incremental children for a pair of axes forming an explorable grid\r\n * @param parent The structured element whose data is being incrmeented\r\n * @param field The data fields used to compare idividual data points\r\n * @param firstValues Array of tick values for the first axis\r\n * @param secondValues Array of tick values for the second axis\r\n * @param data The array of data used in the visualization\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateGridChildren(parent, fields, firstValues, secondValues, data) {\r\n    let childNodes = [];\r\n    const filterData = (xLowerBound, yLowerBound, xUpperBound, yUpperBound) => {\r\n        return data.filter((val) => {\r\n            const inRange = (field, r1, r2) => {\r\n                if (r2) {\r\n                    return val[field] >= r1 && val[field] < r2;\r\n                }\r\n                else {\r\n                    return val[field] === r1;\r\n                }\r\n            };\r\n            return inRange(fields[1], xLowerBound, xUpperBound) && inRange(fields[0], yLowerBound, yUpperBound);\r\n        });\r\n    };\r\n    const yIncrements = firstValues.reduce(getEncodingValueIncrements, []);\r\n    const xIncrements = secondValues.reduce(getEncodingValueIncrements, []);\r\n    yIncrements.forEach((yIncrement) => {\r\n        xIncrements.forEach((xIncrement) => {\r\n            const filteredSelection = filterData(xIncrement[0], yIncrement[0], xIncrement[1], yIncrement[1]);\r\n            childNodes.push(informationToNode(`${[yIncrement, xIncrement]}`, parent, filteredSelection, \"filteredData\", filteredSelection));\r\n        });\r\n    });\r\n    return childNodes;\r\n}\r\nfunction isStringArray(data) {\r\n    return data.every((pnt) => typeof pnt === \"string\");\r\n}\r\nfunction getEncodingValueIncrements(incrementArray, currentValue, index, array) {\r\n    if (isStringArray(array)) {\r\n        incrementArray.push([currentValue]);\r\n        return incrementArray;\r\n    }\r\n    else {\r\n        let bounds;\r\n        let reducedIndex = index - 1;\r\n        if (reducedIndex === -1 && currentValue !== 0) {\r\n            const incrementDifference = array[index + 1] - currentValue;\r\n            bounds = [(currentValue - incrementDifference), currentValue];\r\n        }\r\n        else if (index === array.length - 1) {\r\n            const incrementDifference = currentValue - array[index - 1];\r\n            let finalIncrement;\r\n            if (currentValue instanceof Date) {\r\n                finalIncrement = currentValue.getTime() + incrementDifference;\r\n            }\r\n            else {\r\n                finalIncrement = currentValue + incrementDifference;\r\n            }\r\n            incrementArray.push([array[reducedIndex], currentValue]);\r\n            bounds = [currentValue, finalIncrement];\r\n        }\r\n        else {\r\n            bounds = [array[reducedIndex], array[reducedIndex + 1]];\r\n        }\r\n        incrementArray.push([bounds[0], bounds[1]]);\r\n        return incrementArray;\r\n    }\r\n}\r\n/**\r\n * Recursively generates a child node for each data point in the provided range\r\n * @param childrenNodes The array {@link AccessibilityTreeNode} to eventually return\r\n * @param filteredSelection The data points to transform into {@link AccessibilityTreeNode} nodes\r\n * @param parent The parent whose children are being generated\r\n * @returns\r\n */\r\nfunction generateFilteredDataChildren(childrenNodes, filteredSelection, parent) {\r\n    if (filteredSelection.length > 0) {\r\n        const dataPoint = filteredSelection.pop();\r\n        let objCopy = {};\r\n        Object.keys(dataPoint).forEach((key) => {\r\n            if (key.toLowerCase().includes(\"date\")) {\r\n                objCopy[key] = new Date(dataPoint[key]).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' });\r\n            }\r\n            else {\r\n                objCopy[key] = dataPoint[key];\r\n            }\r\n        });\r\n        childrenNodes.push(informationToNode(nodeToDesc(dataPoint), parent, [objCopy], \"data\"));\r\n        generateFilteredDataChildren(childrenNodes, filteredSelection, parent);\r\n    }\r\n    return childrenNodes;\r\n}\r\n/**\r\n * Creates specific children nodes based on a provided {@link NodeType}\r\n * @param type The {@link NodeType} of the parent\r\n * @param parent The parent {@link AccessibilityTreeNode} whose children need to be generated\r\n * @param generationInformation A changing variable that assists in generating children nodes at all levels\r\n * @returns an array of {@link AccessibilityTreeNode}\r\n */\r\nfunction generateChildNodes(type, parent, generationInformation) {\r\n    if (type === \"multiView\") {\r\n        return generateMultiViewChildren(parent, generationInformation);\r\n    }\r\n    else if (type === \"chart\") {\r\n        if (parent.parent) {\r\n            generationInformation.axes.forEach((axis) => {\r\n                axis.data = axis.data.filter((val) => {\r\n                    return Object.keys(val).some((key) => val[key] === generationInformation.facetedValue);\r\n                });\r\n            });\r\n            generationInformation.legends.forEach((legend) => {\r\n                legend.data = legend.data.filter((val) => {\r\n                    return Object.keys(val).some((key) => val[key] === generationInformation.facetedValue);\r\n                });\r\n            });\r\n        }\r\n        return generateChartChildren([], parent, generationInformation.axes, generationInformation.legends, generationInformation.gridNodes);\r\n    }\r\n    else if (type === \"xAxis\" || type === \"yAxis\" || type === \"legend\") {\r\n        return generateStructuredNodeChildren(parent, generationInformation.field, generationInformation.values, generationInformation.data, generationInformation.markUsed);\r\n    }\r\n    else if (type === \"filteredData\") {\r\n        return generateFilteredDataChildren([], generationInformation.map((val) => Object.assign({}, val)), parent);\r\n    }\r\n    else if (type === \"grid\") {\r\n        return generateGridChildren(parent, [generationInformation[0].field, generationInformation[1].field], generationInformation[0].values, generationInformation[1].values, generationInformation[0].data);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Creates a {@link AccessibilityTreeNode} of the given parameters\r\n * @param desc The string that will be used when rendering this node\r\n * @param parent The parent {@link AccessibilityTreeNode} of the node to be generated\r\n * @param selected Selection of data from this node and its children\r\n * @param type Meta-data to know what kind of element this node is from a visualization\r\n * @param childrenInformation changing variable to assist with generating more nodes of the tree\r\n * @returns The {@link AccessibilityTreeNode} from the provided parameters\r\n */\r\nfunction informationToNode(desc, parent, selected, type, childrenInformation) {\r\n    let node = {\r\n        description: desc,\r\n        parent: parent,\r\n        children: [],\r\n        selected: selected,\r\n        type: type,\r\n        fieldsUsed: parent !== null ? parent.fieldsUsed : childrenInformation.dataFieldsUsed\r\n    };\r\n    if (childrenInformation)\r\n        node.children = generateChildNodes(type, node, childrenInformation);\r\n    node.description = nodeToDesc(node);\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param node The node whose description is being created\r\n * @returns A description based on the provided {@link AccessibilityTreeNode}\r\n */\r\nfunction nodeToDesc(node) {\r\n    if (node.type === \"multiView\" || node.type === \"chart\") {\r\n        return node.description;\r\n    }\r\n    else if (node.type === \"xAxis\" || node.type === \"yAxis\") {\r\n        return node.description;\r\n    }\r\n    else if (node.type === `legend`) {\r\n        return node.description;\r\n    }\r\n    else if (node.type === \"filteredData\") {\r\n        return `Range ${node.description} ${node.selected.length} values in the interval`;\r\n    }\r\n    else if (node.type === `grid`) {\r\n        return node.description;\r\n    }\r\n    else if (node.type === 'data') {\r\n        return node.fieldsUsed.reduce((desc, currentKey) => `${desc} ${currentKey}: ${node.selected[0][currentKey]}`, \"\");\r\n    }\r\n    return \"\";\r\n}\r\n\n\n//# sourceURL=webpack://olli/./src/Structure/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"olli\": () => (/* binding */ olli)\n/* harmony export */ });\n/* harmony import */ var _Render_Table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render/Table */ \"./src/Render/Table/index.ts\");\n/* harmony import */ var _Render_TreeView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Render/TreeView */ \"./src/Render/TreeView/index.ts\");\n/* harmony import */ var _Render_TreeView_TreeLink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Render/TreeView/TreeLink */ \"./src/Render/TreeView/TreeLink.ts\");\n/* harmony import */ var _Structure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Structure */ \"./src/Structure/index.ts\");\n\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param config The {@link OlliConfigOptions} object to specify how an accessible visualization should be generated.\r\n */\r\nfunction olli(config) {\r\n    console.log(config);\r\n    let chartEncodingTree = (0,_Structure__WEBPACK_IMPORTED_MODULE_3__.olliVisSpecToTree)(config.visualization);\r\n    let htmlRendering;\r\n    switch (config.renderType) {\r\n        case (\"table\"):\r\n            htmlRendering = (0,_Render_Table__WEBPACK_IMPORTED_MODULE_0__.renderTable)(chartEncodingTree);\r\n            break;\r\n        case ('tree'):\r\n        default:\r\n            htmlRendering = document.createElement(\"ul\").appendChild((0,_Render_TreeView__WEBPACK_IMPORTED_MODULE_1__.renderTree)(chartEncodingTree));\r\n            new _Render_TreeView_TreeLink__WEBPACK_IMPORTED_MODULE_2__.TreeLinks(htmlRendering).init();\r\n    }\r\n    if (config.ariaLabel) {\r\n        htmlRendering.setAttribute(\"aria-label\", config.ariaLabel);\r\n    }\r\n    document.getElementById(config.domId)?.appendChild(htmlRendering);\r\n}\r\nwindow.olli = olli;\r\n\n\n//# sourceURL=webpack://olli/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;