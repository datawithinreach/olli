/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["OlliAdapters"] = factory();
	else
		root["OlliAdapters"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ObservablePlotAdapter.ts":
/*!**************************************!*\
  !*** ./src/ObservablePlotAdapter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObservablePlotAdapter\": () => (/* binding */ ObservablePlotAdapter)\n/* harmony export */ });\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\n/**\r\n * * Adapter to deconstruct ObservablePlot visualizations into an {@link OlliVisSpec}\r\n * @param plot The ObservablePlot spec to render the visualization\r\n * @param svg the rendered SVGElement of the visualization\r\n * @returns the generated {@link OlliVisSpec}\r\n */\r\nvar ObservablePlotAdapter = function (plot, svg) {\r\n    if (hasFacets(plot) || isMultiSeries(plot)) {\r\n        return plotToFacetedChart(plot, svg);\r\n    }\r\n    else {\r\n        return plotToChart(plot, svg);\r\n    }\r\n};\r\n/**\r\n * Specifies that the provided visualization information relates to a faceted chart\r\n * @param plot The ObservablePlot spec to render the visualization\r\n * @param svg the rendered SVGElement of the visualization\r\n * @returns the generated {@link FacetedChart}\r\n */\r\nfunction plotToFacetedChart(plot, svg) {\r\n    var chartSVG = svg.tagName !== 'svg' ? Object.values(svg.children).find(function (n) { return n.tagName === 'svg'; }) : svg;\r\n    var axes = ['x-axis', 'y-axis'].reduce(function (parsedAxes, s) {\r\n        var axisSVG = findHtmlElement(chartSVG, s);\r\n        if (axisSVG) {\r\n            parsedAxes.push(parseAxis(plot, axisSVG));\r\n        }\r\n        return parsedAxes;\r\n    }, []);\r\n    var legends = [];\r\n    if (plot.color && plot.color.legend)\r\n        legends.push(parseLegend(plot, svg.children[0]));\r\n    var plotMark = plot.marks.filter(function (mark) { return mark.ariaLabel !== 'rule'; })[0];\r\n    var fields = axes.concat(legends).reduce(function (fieldArr, guide) { return fieldArr.concat(guide.field); }, []);\r\n    var charts = new Map();\r\n    var facetField = plot.facet ?\r\n        plot.facet.y ?\r\n            plot.facet.y :\r\n            plot.facet.x :\r\n        plot.marks.find(function (mark) { return mark.ariaLabel === 'line'; }).channels.find(function (c) { return c.name === \"stroke\"; }).value;\r\n    if (hasFacets(plot)) {\r\n        charts = new Map(Object.values(chartSVG.children)\r\n            .filter(function (n) { return n.getAttribute('aria-label') === 'facet'; })\r\n            .map(function (n) { return [n.__data__, plotToChart(plot, chartSVG, plotMark.data.filter(function (d) { return d[facetField] === n.__data__; }))]; }));\r\n    }\r\n    else {\r\n        var strokeValues = plotMark.data.reduce(function (values, d) {\r\n            if (!values.includes(d[facetField])) {\r\n                values.push(d[facetField]);\r\n            }\r\n            return values;\r\n        }, []);\r\n        charts = new Map(strokeValues.map(function (s) { return [s, plotToChart(plot, chartSVG, plotMark.data.filter(function (d) { return d[facetField] === s; }))]; }));\r\n    }\r\n    var facetedChart = {\r\n        type: \"facetedChart\",\r\n        charts: charts,\r\n        data: plotMark.data,\r\n        dataFieldsUsed: fields,\r\n        description: \"Faceted chart\",\r\n        facetedField: facetField,\r\n    };\r\n    return facetedChart;\r\n}\r\n/**\r\n * Specifies that the provided visualization information relates to a single chart\r\n * @param plot The ObservablePlot spec to render the visualization\r\n * @param svg the rendered Element of the visualization\r\n * @param data A filtered data set used in the chart\r\n * @returns the generated {@link Chart}\r\n */\r\nfunction plotToChart(plot, svg, data) {\r\n    var axes = ['x-axis', 'y-axis'].reduce(function (parsedAxes, s) {\r\n        var chartSVG = svg.tagName !== 'svg' ? Object.values(svg.children).find(function (n) { return n.tagName === 'svg'; }) : svg;\r\n        var axisSVG = findHtmlElement(chartSVG, s);\r\n        if (axisSVG) {\r\n            parsedAxes.push(parseAxis(plot, axisSVG));\r\n        }\r\n        return parsedAxes;\r\n    }, []);\r\n    var legends = [];\r\n    if (plot.color && plot.color.legend)\r\n        legends.push(parseLegend(plot, svg.children[0]));\r\n    var plotMark = plot.marks.filter(function (mark) { return mark.ariaLabel !== 'rule'; })[0];\r\n    var fields = axes.concat(legends).reduce(function (fieldArr, guide) { return fieldArr.concat(guide.field); }, []); //TODO: Same code as vega-lite adapter, create utility functions that can be reused accross adapters\r\n    var chart = {\r\n        axes: axes,\r\n        type: \"chart\",\r\n        legends: legends,\r\n        data: data ? data : plotMark.data,\r\n        dataFieldsUsed: fields,\r\n        description: \"A chart with \".concat(plotMark.ariaLabel, \" marks\"),\r\n        gridNodes: []\r\n    };\r\n    if (identifyMark(plotMark.ariaLabel) !== \"[Undefined]\") {\r\n        chart.markUsed = identifyMark(plotMark.ariaLabel);\r\n    }\r\n    return chart;\r\n}\r\n/**\r\n * Creates an {@link Axis} from the provided spec and svg\r\n * @param plot The ObservablePlot spec to render the visualization\r\n * @param svg the SVG element of an axis\r\n * @returns A {@link Axis} of the visualization\r\n */\r\nfunction parseAxis(plot, svg) {\r\n    var axisType = (svg === null || svg === void 0 ? void 0 : svg.getAttribute('aria-label')) === 'y-axis' ? 'y' : 'x';\r\n    var orient = axisType === 'y' ? 'left' : 'bottom';\r\n    var plotMark = plot.marks.filter(function (mark) { return mark.ariaLabel !== 'rule'; })[0];\r\n    var channel = plotMark.channels.find(function (c) { return c.scale === axisType; });\r\n    var field = typeof channel.value === 'object' ? channel.value.label : channel.value;\r\n    var ticks = Object.keys(svg.children).reduce(function (tArr, k) {\r\n        var cObj = svg.children[parseInt(k)];\r\n        var tickValue = '';\r\n        if (cObj.classList[0] === 'tick') {\r\n            cObj.childNodes.forEach(function (innerChild) {\r\n                if (innerChild.textContent !== '') {\r\n                    tickValue = innerChild.textContent;\r\n                }\r\n            });\r\n        }\r\n        if (tickValue !== '') {\r\n            if (isNaN(parseInt(tickValue))) {\r\n                //@ts-ignore\r\n                tArr.push(tickValue);\r\n            }\r\n            else {\r\n                //@ts-ignore\r\n                tArr.push(parseFloat(tickValue));\r\n            }\r\n        }\r\n        return tArr;\r\n    }, []);\r\n    var guide = {\r\n        values: __spreadArray([], ticks, true),\r\n        title: \"\".concat(svg === null || svg === void 0 ? void 0 : svg.getAttribute('aria-label'), \" titled \").concat(field),\r\n        data: plotMark.data,\r\n        field: field,\r\n        orient: orient\r\n    };\r\n    if (channel.type) {\r\n        guide.scaleType = channel.type;\r\n    }\r\n    return guide;\r\n}\r\n/**\r\n * Creates an {@link Legend} from the provided spec and svg\r\n * @param plot The ObservablePlot spec to render the visualization\r\n * @param svg the SVG element of an legend\r\n * @returns A {@link Legend} of the visualization\r\n */\r\nfunction parseLegend(plot, svg) {\r\n    var plotMark = plot.marks.filter(function (mark) { return mark.ariaLabel !== 'rule'; })[0];\r\n    var channel = plotMark.channels.find(function (c) { return c.scale === 'color'; });\r\n    var values = Object.keys(svg.children).reduce(function (a, k) {\r\n        var c = svg.children[parseInt(k)];\r\n        if (c.nodeName !== 'STYLE') {\r\n            if (isNaN(parseInt(c.textContent))) {\r\n                a.push(c.textContent);\r\n            }\r\n            else {\r\n                a.push(parseInt(c.textContent));\r\n            }\r\n        }\r\n        return a;\r\n    }, []);\r\n    var guide = {\r\n        values: values,\r\n        data: plotMark.data,\r\n        field: channel.value,\r\n        title: channel.value,\r\n        type: 'ordinal',\r\n    };\r\n    if (identifyMark(plotMark.ariaLabel) !== \"[Undefined]\") {\r\n        guide.markUsed = identifyMark(plotMark.ariaLabel);\r\n    }\r\n    if (plot.color.type)\r\n        guide.type = plot.color.type;\r\n    return guide;\r\n}\r\n/**\r\n * Finds a specified HTML element from a provided string\r\n * @param svg the root HTML Element to begin the search\r\n * @param label the string of the HTML element to search for\r\n * @returns the found HTML Element or undefined if no element was found\r\n */\r\nfunction findHtmlElement(svg, label) {\r\n    var attributeToCompare = 'aria-label';\r\n    var returnedElement;\r\n    Object.keys(svg.children).forEach(function (k) {\r\n        var childElement = svg.children[parseInt(k)];\r\n        if (childElement.getAttribute(attributeToCompare) === label) {\r\n            returnedElement = childElement;\r\n        }\r\n    });\r\n    return returnedElement;\r\n}\r\n/**\r\n * Determines if the provided ObservablePlot object is a faceted chart.\r\n * @param plot The spec to check\r\n * @returns True if any facets exist and false otherwise\r\n */\r\nfunction hasFacets(plot) {\r\n    return plot.facet;\r\n}\r\n/**\r\n * Determines if the provided ObservablePlot object is a multi-series line chart.\r\n * @param plot The spec to check\r\n * @returns True if multiple lines exist and false otherwise\r\n */\r\nfunction isMultiSeries(plot) {\r\n    var lineMarks = plot.marks.find(function (mark) { return mark.ariaLabel === 'line'; });\r\n    return lineMarks && lineMarks.channels.some(function (c) { return c.name === \"stroke\"; });\r\n}\r\nfunction identifyMark(m) {\r\n    switch (m) {\r\n        case ('dot'):\r\n            return \"point\";\r\n        case ('bar'):\r\n            return \"rect\";\r\n        case ('line'):\r\n            return \"line\";\r\n        default:\r\n            return \"[Undefined]\";\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://OlliAdapters/./src/ObservablePlotAdapter.ts?");

/***/ }),

/***/ "./src/Types.ts":
/*!**********************!*\
  !*** ./src/Types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"chart\": () => (/* binding */ chart),\n/* harmony export */   \"facetedChart\": () => (/* binding */ facetedChart),\n/* harmony export */   \"nestedChart\": () => (/* binding */ nestedChart)\n/* harmony export */ });\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar chart = function (fields) {\r\n    return __assign(__assign({}, fields), { type: \"chart\" });\r\n};\r\nvar facetedChart = function (fields) {\r\n    return __assign(__assign({}, fields), { type: \"facetedChart\" });\r\n};\r\nvar nestedChart = function (fields) {\r\n    return __assign(__assign({}, fields), { type: \"nestedChart\" });\r\n};\r\n\n\n//# sourceURL=webpack://OlliAdapters/./src/Types.ts?");

/***/ }),

/***/ "./src/VegaAdapter.ts":
/*!****************************!*\
  !*** ./src/VegaAdapter.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VegaAdapter\": () => (/* binding */ VegaAdapter),\n/* harmony export */   \"findScenegraphNodes\": () => (/* binding */ findScenegraphNodes),\n/* harmony export */   \"verifyNode\": () => (/* binding */ verifyNode)\n/* harmony export */ });\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Types */ \"./src/Types.ts\");\n\r\nvar view;\r\nvar spec;\r\n/**\r\n* Adapter function that breaks down a Vega visualization into it's basic visual grammar\r\n* @param view The Vega Scenegraph object used in the visualization\r\n* @param spec The Vega Specification used to generate the visualization\r\n* @returns the {@link OlliVisSpec}, the non-concrete visualization information that can be later used to\r\n* generate the Accessibility Tree Encoding\r\n*/\r\nvar VegaAdapter = function (visObject, helperVisInformation) {\r\n    view = visObject;\r\n    spec = helperVisInformation;\r\n    if (view.items.some(function (el) { return el.role === \"scope\"; })) {\r\n        return parseMultiViewChart();\r\n    }\r\n    else {\r\n        return parseSingleChart(view);\r\n    }\r\n};\r\nfunction parseMultiViewChart() {\r\n    var filterUniqueNodes = (function (nodeArr) {\r\n        var uniqueNodes = [];\r\n        nodeArr.forEach(function (node) {\r\n            if (uniqueNodes.every(function (un) { return JSON.stringify(un) !== JSON.stringify(node); })) {\r\n                uniqueNodes.push(node);\r\n            }\r\n        });\r\n        return uniqueNodes;\r\n    });\r\n    var baseVisDescription = vegaVisDescription(spec);\r\n    var axes = filterUniqueNodes(findScenegraphNodes(view, \"axis\").map(function (axisNode) { return parseAxisInformation(axisNode); }));\r\n    var legends = filterUniqueNodes(findScenegraphNodes(view, \"legend\").map(function (legendNode) { return parseLegendInformation(legendNode); }));\r\n    var chartItems = view.items.filter(function (el) { return el.role === \"scope\"; })[0].items;\r\n    var charts = chartItems.map(function (chartNode) {\r\n        var chart = parseSingleChart(chartNode);\r\n        chart.title = findScenegraphNodes(chartNode, \"title-text\").length > 0 ?\r\n            findScenegraphNodes(chartNode, \"title-text\")[0].items[0].text : '';\r\n        return chart;\r\n    });\r\n    var multiViewChart = (0,_Types__WEBPACK_IMPORTED_MODULE_0__.nestedChart)({\r\n        charts: charts,\r\n        data: getData(),\r\n        dataFieldsUsed: getDataFields(axes, legends),\r\n        description: baseVisDescription,\r\n    });\r\n    var shallowCopyArray = function (objToCopy, arrToPush) {\r\n        objToCopy.forEach(function (obj) {\r\n            var objCopy = Object.assign({}, obj);\r\n            objCopy.data = JSON.parse(JSON.stringify(obj.data));\r\n            arrToPush.push(objCopy);\r\n        });\r\n    };\r\n    multiViewChart.charts.forEach(function (chart) {\r\n        shallowCopyArray(axes, chart.axes);\r\n        shallowCopyArray(legends, chart.legends);\r\n    });\r\n    return multiViewChart;\r\n}\r\nfunction parseSingleChart(ch) {\r\n    var baseVisDescription = vegaVisDescription(spec);\r\n    var axes = findScenegraphNodes(ch, \"axis\").map(function (axisNode) { return parseAxisInformation(axisNode); });\r\n    var legends = findScenegraphNodes(ch, \"legend\").map(function (legendNode) { return parseLegendInformation(legendNode); });\r\n    var gridNodes = getGridNodes(axes);\r\n    var dataFields = getDataFields(axes, legends);\r\n    var data = getData();\r\n    var chartTitle = findScenegraphNodes(ch, \"title\").length > 0 ?\r\n        findScenegraphNodes(ch, \"title\")[0].items[0].items[0].items[0].text\r\n        : undefined;\r\n    var chartNode = (0,_Types__WEBPACK_IMPORTED_MODULE_0__.chart)({\r\n        data: data,\r\n        axes: axes,\r\n        legends: legends,\r\n        description: baseVisDescription,\r\n        gridNodes: gridNodes,\r\n        dataFieldsUsed: dataFields\r\n    });\r\n    if (chartTitle) {\r\n        chartNode.title = chartTitle;\r\n    }\r\n    return chartNode;\r\n}\r\nfunction getData() {\r\n    console.log(view);\r\n    try {\r\n        // let data: Map<string, any[]> = new Map()\r\n        // const datasets = spec.data?.map((set: any) => set.name)!\r\n        // datasets.map((key: string) => data.set(key, view.context.data[key].values.value));\r\n        // return data\r\n        return view.context.data['source_0'].values.value;\r\n        // TODO hardcoded dataset name\r\n    }\r\n    catch (error) {\r\n        throw new Error(\"No data defined in the Vega Spec \\n \".concat(error));\r\n    }\r\n}\r\n/**\r\n * @returns the general high-level description of the visualization\r\n */\r\nfunction vegaVisDescription(spec) {\r\n    return spec.description ? spec.description : \"[Root]\";\r\n}\r\n/**\r\n * @returns a key-value pairing of the axis orientation and the {@link Guide} of the corresponding axis\r\n */\r\nfunction parseAxisInformation(axis) {\r\n    var _a, _b, _c, _d;\r\n    var axisView = axis.items[0];\r\n    var ticks = axisView.items.find(function (n) { return n.role === 'axis-tick'; }).items.map(function (n) { return n.datum.value; });\r\n    var title = axisView.items.find(function (n) { return n.role === \"axis-title\"; });\r\n    var scale = axisView.datum.scale;\r\n    var scaleDomain = (_b = (_a = spec.scales) === null || _a === void 0 ? void 0 : _a.find(function (specScale) { return specScale.name === scale; })) === null || _b === void 0 ? void 0 : _b.domain;\r\n    var fields;\r\n    if (scaleDomain.field !== undefined) {\r\n        fields = scaleDomain.field;\r\n    }\r\n    else {\r\n        fields = scaleDomain.fields;\r\n    }\r\n    var axisStr = axisView.orient === \"bottom\" || axisView.orient === \"top\" ? \"X-Axis\" : \"Y-Axis\";\r\n    var orient = axisView.orient;\r\n    return {\r\n        values: ticks,\r\n        title: title === undefined ? axisStr : \"\".concat(axisStr, \" titled '\").concat(title.items[0].text, \"'\"),\r\n        data: getData(),\r\n        field: fields,\r\n        scaleType: (_d = (_c = spec.scales) === null || _c === void 0 ? void 0 : _c.find(function (specScale) { return specScale.name === scale; })) === null || _d === void 0 ? void 0 : _d.type,\r\n        orient: orient\r\n    };\r\n}\r\n/**\r\n * @returns a key-value pairing of the legend name and the {@link Guide} of the corresponding axis\r\n */\r\nfunction parseLegendInformation(legendNode) {\r\n    var _a, _b, _c, _d;\r\n    var scale = legendNode.items[0].datum.scales[Object.keys(legendNode.items[0].datum.scales)[0]];\r\n    var data = getData();\r\n    var labels = legendNode.items[0].items.find(function (n) { return n.role === \"legend-entry\"; }).items[0].items[0].items;\r\n    var title = legendNode.items[0].items.find(function (n) { return n.role === \"legend-title\"; }).items[0].text;\r\n    var field;\r\n    var legendDomain = (_b = (_a = spec.scales) === null || _a === void 0 ? void 0 : _a.find(function (specScale) { return specScale.name === scale; })) === null || _b === void 0 ? void 0 : _b.domain;\r\n    if (legendDomain.field) {\r\n        field = legendDomain.field;\r\n    }\r\n    else {\r\n        if (Object.keys(data[0]).some(function (key) { return key.toLocaleString() === title.toLocaleLowerCase(); })) {\r\n            field = title.toLocaleLowerCase();\r\n        }\r\n    }\r\n    return {\r\n        values: labels.map(function (n) { return n.items.find(function (el) { return el.role === \"legend-label\"; }).items[0].datum.value; }),\r\n        title: title,\r\n        data: data,\r\n        field: field,\r\n        scaleType: (_d = (_c = spec.scales) === null || _c === void 0 ? void 0 : _c.find(function (specScale) { return specScale.name === scale; })) === null || _d === void 0 ? void 0 : _d.type,\r\n        type: \"\"\r\n    };\r\n}\r\n/**\r\n * Finds the corresponding data that a scale refers to\r\n * @param scale The name of the scale to compare in the Vega Spec\r\n * @returns The array of objects that the scale uses.\r\n */\r\nfunction getScaleData(data, scale) {\r\n    var _a;\r\n    var scaleDomain = (_a = spec.scales) === null || _a === void 0 ? void 0 : _a.find(function (s) { return scale === s.name; }).domain;\r\n    var dataRef = scaleDomain.data;\r\n    return data.get(dataRef);\r\n}\r\n/**\r\n * Determines if the chart has the eligible qualities to have a navigable grid node\r\n * @returns the {@link Guide} nodes of that are used for the grid\r\n */\r\nfunction getGridNodes(axes) {\r\n    var gridAxes = view.items.filter(function (el) { return el.role === \"axis\" && el.items[0].items.some(function (it) { return it.role === \"axis-grid\"; }); });\r\n    return gridAxes.map(function (axis) {\r\n        return axes[axis.items[0].orient];\r\n    });\r\n}\r\n/**\r\n * @returns the fields of the data object that are used throughout the visualization axes legends\r\n */\r\nfunction getDataFields(axes, legends) {\r\n    var fields = [];\r\n    var pushFields = function (obj) {\r\n        Object.keys(obj).forEach(function (key) {\r\n            var usedFields = obj[key].field;\r\n            if (typeof usedFields !== \"string\") {\r\n                usedFields.forEach(function (field) {\r\n                    fields.push(field);\r\n                });\r\n            }\r\n            else {\r\n                fields.push(usedFields);\r\n            }\r\n        });\r\n    };\r\n    pushFields(axes);\r\n    pushFields(legends);\r\n    return fields;\r\n}\r\nfunction findScenegraphNodes(scenegraphNode, passRole) {\r\n    var nodes = [];\r\n    var cancelRoles = [\"cell\", \"axis-grid\"];\r\n    if (scenegraphNode.items === undefined) {\r\n        return nodes;\r\n    }\r\n    scenegraphNode.items.forEach(function (nestedItem) {\r\n        if (nestedItem.role !== undefined) {\r\n            if (nestedItem.role === passRole && verifyNode(nestedItem, cancelRoles)) {\r\n                nodes.push(nestedItem);\r\n            }\r\n            else {\r\n                nodes = nodes.concat(findScenegraphNodes(nestedItem, passRole));\r\n            }\r\n        }\r\n        else {\r\n            nodes = nodes.concat(findScenegraphNodes(nestedItem, passRole));\r\n        }\r\n    });\r\n    return nodes;\r\n}\r\nfunction verifyNode(scenegraphNode, cancelRoles) {\r\n    if (scenegraphNode.role !== undefined && !cancelRoles.some(function (role) { return scenegraphNode.role.includes(role); })) {\r\n        if (scenegraphNode.items.every(function (item) { return verifyNode(item, cancelRoles); }) || scenegraphNode.items === undefined) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else if (scenegraphNode.role === undefined && scenegraphNode.items !== undefined) {\r\n        return scenegraphNode.items.every(function (item) { return verifyNode(item, cancelRoles); });\r\n    }\r\n    else if (scenegraphNode.role === undefined && scenegraphNode.items === undefined) {\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://OlliAdapters/./src/VegaAdapter.ts?");

/***/ }),

/***/ "./src/VegaLiteAdapter.ts":
/*!********************************!*\
  !*** ./src/VegaLiteAdapter.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VegaLiteAdapter\": () => (/* binding */ VegaLiteAdapter),\n/* harmony export */   \"findScenegraphNodes\": () => (/* binding */ findScenegraphNodes)\n/* harmony export */ });\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Types */ \"./src/Types.ts\");\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\n\r\n/**\r\n * Adapter to deconstruct Vega-Lite visualizations into an {@link OlliVisSpec}\r\n * @param visObject The Vega Scenegraph from the view\r\n * @param helperVisInformation The Vega-Lite Spec that rendered the visualization\r\n * @returns An {@link OlliVisSpec} of the deconstructed Vega-Lite visualization\r\n */\r\nvar VegaLiteAdapter = function (visObject, helperVisInformation) {\r\n    if (visObject.items.some(function (node) { return node.role === 'scope'; })) {\r\n        return parseMultiView(visObject, helperVisInformation);\r\n    }\r\n    else {\r\n        return parseChart(visObject, helperVisInformation);\r\n    }\r\n};\r\n/**\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns An {@link OlliVisSpec} of the deconstructed Vega-Lite visualization\r\n */\r\nfunction parseMultiView(scenegraph, spec) {\r\n    var filterUniqueNodes = (function (nodeArr) {\r\n        var uniqueNodes = [];\r\n        nodeArr.forEach(function (node) {\r\n            if (uniqueNodes.every(function (un) { return JSON.stringify(un) !== JSON.stringify(node); })) {\r\n                uniqueNodes.push(node);\r\n            }\r\n        });\r\n        return uniqueNodes;\r\n    });\r\n    var shallowCopyArray = function (objToCopy, arrToPush) {\r\n        objToCopy.forEach(function (obj) {\r\n            var objCopy = Object.assign({}, obj);\r\n            objCopy.data = JSON.parse(JSON.stringify(obj.data));\r\n            arrToPush.push(objCopy);\r\n        });\r\n    };\r\n    var axes = filterUniqueNodes(findScenegraphNodes(scenegraph, \"axis\").map(function (axis) { return parseAxis(scenegraph, axis, spec); }));\r\n    var legends = filterUniqueNodes(findScenegraphNodes(scenegraph, \"legend\").map(function (legend) { return parseLegend(scenegraph, legend, spec); }));\r\n    var fields = axes.concat(legends).reduce(function (fieldArr, guide) { return fieldArr.concat(guide.field); }, []);\r\n    var facetedField = spec.encoding.facet !== undefined ? spec.encoding.facet.field : spec.encoding['color'].field;\r\n    var nestedHeirarchies = new Map(scenegraph.items.filter(function (el) { return el.role === \"scope\"; })[0].items\r\n        .map(function (chart) {\r\n        var chartData = parseChart(chart, spec);\r\n        shallowCopyArray(axes, chartData.axes);\r\n        shallowCopyArray(legends, chartData.legends);\r\n        modifyVisFromMark(chartData, chartData.markUsed, spec);\r\n        return [chart.datum[facetedField], chartData];\r\n    }));\r\n    var node = (0,_Types__WEBPACK_IMPORTED_MODULE_0__.facetedChart)({\r\n        description: \"\",\r\n        data: getVisualizationData(scenegraph, spec),\r\n        dataFieldsUsed: fields,\r\n        charts: nestedHeirarchies,\r\n        facetedField: facetedField\r\n    });\r\n    node.dataFieldsUsed.push(facetedField);\r\n    constructChartDescription(node, spec);\r\n    return node;\r\n}\r\n/**\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns An {@link OlliVisSpec} of the deconstructed Vega-Lite visualization\r\n */\r\nfunction parseChart(scenegraph, spec) {\r\n    var axes = findScenegraphNodes(scenegraph, \"axis\").map(function (axis) { return parseAxis(scenegraph, axis, spec); });\r\n    var legends = findScenegraphNodes(scenegraph, \"legend\").map(function (legend) { return parseLegend(scenegraph, legend, spec); });\r\n    var fields = axes.concat(legends).reduce(function (fieldArr, guide) { return fieldArr.concat(guide.field); }, []);\r\n    var mark = spec.mark;\r\n    var node = (0,_Types__WEBPACK_IMPORTED_MODULE_0__.chart)({\r\n        axes: axes.filter(function (axis) { return axis.field !== undefined; }),\r\n        legends: legends,\r\n        description: \"\",\r\n        dataFieldsUsed: fields,\r\n        gridNodes: [],\r\n        data: getVisualizationData(scenegraph, spec),\r\n        markUsed: mark\r\n    });\r\n    constructChartDescription(node, spec);\r\n    modifyVisFromMark(node, mark, spec);\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param axisScenegraphNode The specific scenegraph node of an axis\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns A {@link Axis} from the converted axisScenegraphNode\r\n */\r\nfunction parseAxis(scenegraph, axisScenegraphNode, spec) {\r\n    var axisView = axisScenegraphNode.items[0];\r\n    var orient = axisView.orient;\r\n    var encodingKey = orient === 'bottom' ? 'x' : 'y';\r\n    var ticks = axisView.items.find(function (n) { return n.role === 'axis-tick'; }).items.map(function (n) { return n.datum.value; });\r\n    var title = spec.encoding[encodingKey].title;\r\n    var scale = axisView.datum.scale;\r\n    var axisData = getVisualizationData(scenegraph, spec);\r\n    var axisStr = axisView.orient === \"bottom\" || axisView.orient === \"top\" ? \"X-Axis\" : \"Y-Axis\";\r\n    var field;\r\n    if (spec.encoding[encodingKey].aggregate) {\r\n        field = Object.keys(axisData[0]).filter(function (key) { return key.includes(spec.encoding[encodingKey].field); });\r\n    }\r\n    else {\r\n        field = spec.encoding[encodingKey].field;\r\n    }\r\n    return {\r\n        values: ticks,\r\n        title: title === undefined ? axisStr : \"\".concat(axisStr, \" titled '\").concat(title, \"'\"),\r\n        data: axisData,\r\n        field: field,\r\n        scaleType: spec.encoding[encodingKey].type,\r\n        orient: orient,\r\n        markUsed: spec.mark\r\n    };\r\n}\r\n/**\r\n *\r\n * @param scenegraph The Vega Scenegraph from the view\r\n * @param legendScenegraphNode The specific scenegraph node of a legend\r\n * @param spec The Vega-Lite Spec that rendered the visualization\r\n * @returns A {@link legend} from the converted legendScenegraphNode\r\n */\r\nfunction parseLegend(scenegraph, legendScenegraphNode, spec) {\r\n    var _a, _b;\r\n    var scale = legendScenegraphNode.items[0].datum.scales[Object.keys(legendScenegraphNode.items[0].datum.scales)[0]];\r\n    var data = getVisualizationData(scenegraph, spec);\r\n    var labels = legendScenegraphNode.items[0].items.find(function (n) { return n.role === \"legend-entry\"; }).items[0].items[0].items;\r\n    return {\r\n        values: labels.map(function (n) { return n.items.find(function (el) { return el.role === \"legend-label\"; }).items[0].datum.value; }),\r\n        title: spec.encoding['color'].title ? spec.encoding['color'].title : spec.encoding['color'].field,\r\n        data: data,\r\n        field: spec.encoding['color'].field,\r\n        scaleType: (_b = (_a = spec.scales) === null || _a === void 0 ? void 0 : _a.find(function (specScale) { return specScale.name === scale; })) === null || _b === void 0 ? void 0 : _b.type,\r\n        type: spec.encoding['color'].type,\r\n        markUsed: spec.mark\r\n    };\r\n}\r\n/**\r\n *\r\n * @param node The {@link OlliVisSpec} whose description is being modified\r\n * @param spec The specification of the Vega-Lite visualization being deconstructed\r\n */\r\nfunction constructChartDescription(node, spec) {\r\n    var desc = spec.description ? spec.description : \"\";\r\n    if (node.type === \"facetedChart\") {\r\n        desc = \"\".concat(desc, \" with \").concat(node.charts.size, \" faceted charts.\");\r\n        node.description = spec.description;\r\n    }\r\n    else if (node.type === \"nestedChart\") {\r\n        desc = \"\".concat(desc, \" with \").concat(node.charts.length, \" nested charts.\");\r\n        node.description = spec.description;\r\n    }\r\n    else {\r\n        node.description = \"\".concat(desc);\r\n    }\r\n}\r\n/**\r\n * A Map of data used in the visualization\r\n * @param view The Vega Scenegraph of this visualization\r\n * @param spec The Vega-Lite specification for the visualization\r\n * @returns A key-value pair of the data defined in this visualization\r\n */\r\nfunction getVisualizationData(view, spec) {\r\n    try {\r\n        // TODO fix hardcoded dataset name\r\n        var source_0 = view.context.data['source_0'].values.value;\r\n        // let data: Map<string, any[]> = new Map()\r\n        // Object.keys(view.context.data).forEach((key: string) => {\r\n        //     data.set(key, view.context.data[key].values.value)\r\n        // })\r\n        // return data\r\n        return source_0;\r\n    }\r\n    catch (error) {\r\n        throw new Error(\"No data defined in the Spec \\n \".concat(error));\r\n    }\r\n}\r\n/**\r\n * Traverses a provided scenegraph node for nodes of a specific role.\r\n * @param scenegraphNode The root scenegraph node to traverse\r\n * @param passRole The string of the node role to search for\r\n * @returns an array of ndoes that contain the specified role\r\n */\r\nfunction findScenegraphNodes(scenegraphNode, passRole) {\r\n    var nodes = [];\r\n    var cancelRoles = [\"cell\", \"axis-grid\"];\r\n    if (scenegraphNode.items === undefined) {\r\n        return nodes;\r\n    }\r\n    scenegraphNode.items.forEach(function (nestedItem) {\r\n        if (nestedItem.role !== undefined) {\r\n            if (nestedItem.role === passRole && verifyNode(nestedItem, cancelRoles)) {\r\n                nodes.push(nestedItem);\r\n            }\r\n            else {\r\n                nodes = nodes.concat(findScenegraphNodes(nestedItem, passRole));\r\n            }\r\n        }\r\n        else {\r\n            nodes = nodes.concat(findScenegraphNodes(nestedItem, passRole));\r\n        }\r\n    });\r\n    return nodes;\r\n}\r\n/**\r\n * Checks if a scenegraph node or its children do not have any specified role names\r\n * @param scenegraphNode The scenegraph ndoe to traverse\r\n * @param cancelRoles Roles of Scenegraph Nodes that should not be parsed\r\n * @returns True if the provided scenegraph node and its children do not contain any of the cancelRols\r\n */\r\nfunction verifyNode(scenegraphNode, cancelRoles) {\r\n    if (scenegraphNode.role !== undefined && !cancelRoles.some(function (role) { return scenegraphNode.role.includes(role); })) {\r\n        if (scenegraphNode.items.every(function (item) { return verifyNode(item, cancelRoles); }) || scenegraphNode.items === undefined) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else if (scenegraphNode.role === undefined && scenegraphNode.items !== undefined) {\r\n        return scenegraphNode.items.every(function (item) { return verifyNode(item, cancelRoles); });\r\n    }\r\n    else if (scenegraphNode.role === undefined && scenegraphNode.items === undefined) {\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n *\r\n * @param vis The {@link ChartInformation} to update\r\n * @param mark The {@link Mark} used in the provided {@Link ChartInformation}\r\n * @param spec The Vega-Lite specification of the provided visualization\r\n */\r\nfunction modifyVisFromMark(vis, mark, spec) {\r\n    switch (mark) {\r\n        case 'bar':\r\n            var nomAxis_1 = Object.keys(spec.encoding).filter(function (key) {\r\n                return spec.encoding[key].type === \"nominal\" || spec.encoding[key].aggregate === undefined;\r\n            })[0];\r\n            vis.axes = vis.axes.filter(function (visAxis) { return visAxis.title.toLowerCase().includes(\"\".concat(nomAxis_1, \"-axis\")); });\r\n            break;\r\n        case 'geoshape':\r\n            break;\r\n        case 'point':\r\n            if (vis.title) {\r\n                vis.title = \"Scatter plot with title \".concat(vis.title, \" \");\r\n            }\r\n            vis.gridNodes = __spreadArray([], vis.axes, true);\r\n            break;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://OlliAdapters/./src/VegaLiteAdapter.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObservablePlotAdapter\": () => (/* reexport safe */ _ObservablePlotAdapter__WEBPACK_IMPORTED_MODULE_0__.ObservablePlotAdapter),\n/* harmony export */   \"VegaAdapter\": () => (/* reexport safe */ _VegaAdapter__WEBPACK_IMPORTED_MODULE_1__.VegaAdapter),\n/* harmony export */   \"VegaLiteAdapter\": () => (/* reexport safe */ _VegaLiteAdapter__WEBPACK_IMPORTED_MODULE_2__.VegaLiteAdapter)\n/* harmony export */ });\n/* harmony import */ var _ObservablePlotAdapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObservablePlotAdapter */ \"./src/ObservablePlotAdapter.ts\");\n/* harmony import */ var _VegaAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VegaAdapter */ \"./src/VegaAdapter.ts\");\n/* harmony import */ var _VegaLiteAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VegaLiteAdapter */ \"./src/VegaLiteAdapter.ts\");\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://OlliAdapters/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});