/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Render/Table/index.ts":
/*!***********************************!*\
  !*** ./src/Render/Table/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderTable\": () => (/* binding */ renderTable)\n/* harmony export */ });\n/**\r\n *\r\n * @param tree The {@link AccessibilityTreeNode} to generate a table from\r\n * @returns An {@link HTMLElement} table of the data used in a visualization\r\n */\r\nfunction renderTable(tree) {\r\n    var table = document.createElement(\"table\");\r\n    var tableBody = document.createElement(\"tbody\");\r\n    var tableHeaders = document.createElement(\"tr\");\r\n    tree.fieldsUsed.forEach(function (field) {\r\n        var header = document.createElement(\"th\");\r\n        header.innerText = field;\r\n        tableHeaders.appendChild(header);\r\n    });\r\n    tableBody.appendChild(tableHeaders);\r\n    tree.selected.forEach(function (data) {\r\n        var dataRow = document.createElement(\"tr\");\r\n        tree.fieldsUsed.forEach(function (field) {\r\n            var tableData = document.createElement(\"td\");\r\n            tableData.innerText = data[field];\r\n            dataRow.appendChild(tableData);\r\n        });\r\n        tableBody.appendChild(dataRow);\r\n    });\r\n    table.appendChild(tableBody);\r\n    return table;\r\n}\r\n\n\n//# sourceURL=webpack://olli-core/./src/Render/Table/index.ts?");

/***/ }),

/***/ "./src/Render/TreeView/TreeItemLinks.ts":
/*!**********************************************!*\
  !*** ./src/Render/TreeView/TreeItemLinks.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GridTreeItemLink\": () => (/* binding */ GridTreeItemLink),\n/* harmony export */   \"TreeItemLink\": () => (/* binding */ TreeItemLink)\n/* harmony export */ });\n/*\r\n*   This content is licensed according to the W3C Software License at\r\n*   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n*\r\n*   File:   TreeItemLink.js\r\n*\r\n*   Desc:   Treeitem widget that implements ARIA Authoring Practices\r\n*           for a tree being used as a file viewer\r\n*/\r\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/*\r\n*   @constructor\r\n*\r\n*   @desc\r\n*       Treeitem object for representing the state and user interactions for a\r\n*       treeItem widget\r\n*\r\n*   @param node\r\n*       An element with the role=tree attribute\r\n*/\r\nvar TreeItemLink = /** @class */ (function () {\r\n    function TreeItemLink(node, treeObj, group, level) {\r\n        node.tabIndex = -1;\r\n        this.tree = treeObj;\r\n        this.parent = group;\r\n        this.domNode = node;\r\n        this.label = node.textContent.trim();\r\n        this.stopDefaultClick = false;\r\n        this.level = level;\r\n        this.children = [];\r\n        this.lastVisitedChild = null;\r\n        // Check whether node is a DOM element\r\n        if (typeof node !== 'object') {\r\n            return;\r\n        }\r\n        if (node.getAttribute('aria-label')) {\r\n            this.label = node.getAttribute('aria-label').trim();\r\n        }\r\n        this.isExpandable = false;\r\n        this.isVisible = false;\r\n        this.inGroup = false;\r\n        if (group) {\r\n            this.inGroup = true;\r\n        }\r\n        var elem = node.firstElementChild;\r\n        while (elem) {\r\n            if (elem.tagName.toLowerCase() == 'ul') {\r\n                elem.setAttribute('role', 'group');\r\n                this.isExpandable = true;\r\n                break;\r\n            }\r\n            elem = elem.nextElementSibling;\r\n        }\r\n        this.keyCode = Object.freeze({\r\n            RETURN: 13,\r\n            SPACE: 32,\r\n            PAGEUP: 33,\r\n            PAGEDOWN: 34,\r\n            END: 35,\r\n            HOME: 36,\r\n            LEFT: 37,\r\n            UP: 38,\r\n            RIGHT: 39,\r\n            DOWN: 40,\r\n            X: 88,\r\n            Y: 89,\r\n            L: 76,\r\n            G: 71,\r\n            W: 87,\r\n            A: 65,\r\n            S: 83,\r\n            D: 68,\r\n            ESCAPE: 27,\r\n            PLUS: 107,\r\n            MINUS: 189\r\n        });\r\n    }\r\n    TreeItemLink.prototype.init = function () {\r\n        this.domNode.tabIndex = -1;\r\n        if (!this.domNode.getAttribute('role')) {\r\n            this.domNode.setAttribute('role', 'treeitem');\r\n        }\r\n        this.domNode.addEventListener('keydown', this.handleKeydown.bind(this));\r\n        this.domNode.addEventListener('click', this.handleClick.bind(this));\r\n        this.domNode.addEventListener('focus', this.handleFocus.bind(this));\r\n        this.domNode.addEventListener('blur', this.handleBlur.bind(this));\r\n        if (this.isExpandable) {\r\n            this.domNode.firstElementChild.addEventListener('mouseover', this.handleMouseOver.bind(this));\r\n            this.domNode.firstElementChild.addEventListener('mouseout', this.handleMouseOut.bind(this));\r\n        }\r\n        else {\r\n            this.domNode.addEventListener('mouseover', this.handleMouseOver.bind(this));\r\n            this.domNode.addEventListener('mouseout', this.handleMouseOut.bind(this));\r\n        }\r\n    };\r\n    TreeItemLink.prototype.isExpanded = function () {\r\n        if (this.isExpandable) {\r\n            return this.domNode.getAttribute('aria-expanded') === 'true';\r\n        }\r\n        return false;\r\n    };\r\n    /* EVENT HANDLERS */\r\n    TreeItemLink.prototype.handleKeydown = function (event) {\r\n        this.stopDefaultClick = false;\r\n        if (event.altKey || event.ctrlKey || event.metaKey) {\r\n            return;\r\n        }\r\n        if (event.shiftKey) {\r\n            var root = this.getRootNode();\r\n            if (event.keyCode == this.keyCode.SPACE || event.keyCode == this.keyCode.RETURN) {\r\n                event.stopPropagation();\r\n                this.stopDefaultClick = true;\r\n            }\r\n            else if (root.label.includes('nested charts') && event.target === this.domNode) {\r\n                var nodePosition = function (item) {\r\n                    var arr = [];\r\n                    var node = item;\r\n                    while (node !== undefined) {\r\n                        if (node.parent) {\r\n                            var index = node.parent.children.indexOf(node);\r\n                            if (index !== -1) {\r\n                                arr.push(index);\r\n                            }\r\n                        }\r\n                        node = node.parent;\r\n                    }\r\n                    return arr;\r\n                };\r\n                if (event.keyCode === this.keyCode.LEFT) {\r\n                    var pos = nodePosition(this).reverse();\r\n                    pos[0] = pos[0] - 1;\r\n                    if (pos[0] >= 0) {\r\n                        this.shiftToNode(pos);\r\n                    }\r\n                }\r\n                else if (event.keyCode === this.keyCode.RIGHT) {\r\n                    var pos = nodePosition(this).reverse();\r\n                    pos[0] = pos[0] + 1;\r\n                    if (pos[pos.length - 1] < root.children.length) {\r\n                        this.shiftToNode(pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.checkBaseKeys(event);\r\n        }\r\n    };\r\n    TreeItemLink.prototype.checkBaseKeys = function (event) {\r\n        var flag = false;\r\n        switch (event.keyCode) {\r\n            case this.keyCode.SPACE:\r\n            case this.keyCode.RETURN:\r\n                if (this.isExpandable) {\r\n                    if (this.isExpanded()) {\r\n                        this.tree.collapseTreeitem(this);\r\n                    }\r\n                    else {\r\n                        this.tree.expandTreeitem(this);\r\n                    }\r\n                    flag = true;\r\n                }\r\n                else {\r\n                    event.stopPropagation();\r\n                    this.stopDefaultClick = true;\r\n                }\r\n                break;\r\n            case this.keyCode.DOWN:\r\n                if (this.children.length > 0) {\r\n                    if (this.isExpandable)\r\n                        this.tree.expandTreeitem(this);\r\n                    this.tree.setFocusToNextLaver();\r\n                }\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.LEFT:\r\n                this.tree.setFocusToPreviousItem();\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.RIGHT:\r\n                this.tree.setFocusToNextItem();\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.ESCAPE:\r\n            case this.keyCode.UP:\r\n                if (this.isExpandable && this.isExpanded()) {\r\n                    this.tree.setFocusToParentItem();\r\n                    this.tree.collapseTreeitem(this);\r\n                    flag = true;\r\n                }\r\n                else {\r\n                    if (this.inGroup) {\r\n                        this.tree.setFocusToParentItem();\r\n                        flag = true;\r\n                    }\r\n                }\r\n                break;\r\n            case this.keyCode.HOME:\r\n                this.tree.setFocusToItem(this.parent.children[0]);\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.END:\r\n                this.tree.setFocusToItem(this.parent.children[this.parent.children.length - 1]);\r\n                flag = true;\r\n                break;\r\n            case this.keyCode.X:\r\n                // this.tree.focusOnSpecificNode(\"x-axis\", this)\r\n                break;\r\n            case this.keyCode.Y:\r\n                // this.tree.focusOnSpecificNode(\"y-axis\", this)\r\n                break;\r\n            case this.keyCode.L:\r\n                // this.tree.focusOnSpecificNode(\"legend\", this)\r\n                break;\r\n        }\r\n        if (flag) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n    };\r\n    TreeItemLink.prototype.handleClick = function (event) {\r\n        // only process click events that directly happened on this treeitem\r\n        if (event.target !== this.domNode && event.target !== this.domNode.firstElementChild) {\r\n            return;\r\n        }\r\n        if (this.isExpandable) {\r\n            if (this.isExpanded()) {\r\n                this.tree.setFocusToItem(this);\r\n                this.tree.collapseTreeitem(this);\r\n            }\r\n            else {\r\n                if (this.isExpandable && !this.isExpanded()) {\r\n                    this.tree.expandTreeitem(this);\r\n                    this.tree.setFocusToItem(this);\r\n                }\r\n                this.tree.setFocusToNextLaver();\r\n            }\r\n            event.stopPropagation();\r\n        }\r\n    };\r\n    TreeItemLink.prototype.handleFocus = function (event) {\r\n        var node = this.domNode;\r\n        if (this.isExpandable) {\r\n            node = node.firstElementChild;\r\n        }\r\n        node.classList.add('focus');\r\n    };\r\n    TreeItemLink.prototype.handleBlur = function (event) {\r\n        var node = this.domNode;\r\n        if (this.isExpandable) {\r\n            node = node.firstElementChild;\r\n        }\r\n        node.classList.remove('focus');\r\n    };\r\n    TreeItemLink.prototype.handleMouseOver = function (event) {\r\n        event.currentTarget.classList.add('hover');\r\n    };\r\n    TreeItemLink.prototype.handleMouseOut = function (event) {\r\n        event.currentTarget.classList.remove('hover');\r\n    };\r\n    TreeItemLink.prototype.getRootNode = function () {\r\n        if (this.parent !== undefined) {\r\n            return this.parent.getRootNode();\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    };\r\n    TreeItemLink.prototype.shiftToNode = function (pos) {\r\n        var node = pos.reduce(function (nodeToReturn, posNum, i) {\r\n            if (nodeToReturn.children[posNum] === undefined) {\r\n                return nodeToReturn;\r\n            }\r\n            else {\r\n                return nodeToReturn.children[posNum];\r\n            }\r\n        }, this.getRootNode());\r\n        this.tree.setFocusToAdjacentItem(node);\r\n    };\r\n    return TreeItemLink;\r\n}());\r\n\r\nvar GridTreeItemLink = /** @class */ (function (_super) {\r\n    __extends(GridTreeItemLink, _super);\r\n    function GridTreeItemLink(node, treeObj, group, level) {\r\n        var _this = _super.call(this, node, treeObj, group, level) || this;\r\n        var getNodeFromString = function (partialLabelString) {\r\n            return _this.parent.parent.children.reduce(function (returnVal, currentNode) {\r\n                if (currentNode.label.includes(partialLabelString)) {\r\n                    return currentNode;\r\n                }\r\n                else {\r\n                    return returnVal;\r\n                }\r\n            });\r\n        };\r\n        _this.gridIndex = _this.parent.children.length;\r\n        _this.gridWidth = _this.parent.parent.label.includes('facet') ? getNodeFromString(\"Y-Axis\").children.length : getNodeFromString(\"X-Axis\").children.length;\r\n        var getRowPosition = function () {\r\n            if (_this.gridIndex !== 0) {\r\n                var prevPosition = _this.parent.children[_this.gridIndex - 1].rowPosition;\r\n                return prevPosition === _this.gridWidth ? 1 : prevPosition + 1;\r\n            }\r\n            else {\r\n                return 1;\r\n            }\r\n        };\r\n        _this.rowPosition = getRowPosition();\r\n        return _this;\r\n    }\r\n    GridTreeItemLink.prototype.handleKeydown = function (event) {\r\n        _super.prototype.handleKeydown.call(this, event);\r\n        var currentChildIndex = this.parent.children.indexOf(this);\r\n        switch (event.keyCode) {\r\n            case this.keyCode.W:\r\n                if (currentChildIndex + this.gridWidth < this.parent.children.length) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex + this.gridWidth]);\r\n                }\r\n                break;\r\n            case this.keyCode.S:\r\n                if (currentChildIndex - this.gridWidth >= 0) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex - this.gridWidth]);\r\n                }\r\n                break;\r\n            case this.keyCode.A:\r\n                if (this.rowPosition > 1) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex - 1]);\r\n                }\r\n                break;\r\n            case this.keyCode.D:\r\n                if (this.rowPosition < this.gridWidth) {\r\n                    this.tree.setFocusToItem(this.parent.children[currentChildIndex + 1]);\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    return GridTreeItemLink;\r\n}(TreeItemLink));\r\n\r\n\n\n//# sourceURL=webpack://olli-core/./src/Render/TreeView/TreeItemLinks.ts?");

/***/ }),

/***/ "./src/Render/TreeView/TreeLink.ts":
/*!*****************************************!*\
  !*** ./src/Render/TreeView/TreeLink.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TreeLinks\": () => (/* binding */ TreeLinks)\n/* harmony export */ });\n/* harmony import */ var _TreeItemLinks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeItemLinks */ \"./src/Render/TreeView/TreeItemLinks.ts\");\n\r\n/*\r\n*   This content is licensed according to the W3C Software License at\r\n*   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n*\r\n*   File:   TreeLinks.ts\r\n*\r\n*   Desc:   Tree widget that implements ARIA Authoring Practices\r\n*           for a tree being used as a file viewer\r\n*/\r\n/*\r\n*   @constructor\r\n*\r\n*   @desc\r\n*       Tree item object for representing the state and user interactions for a\r\n*       tree widget\r\n*\r\n*   @param node\r\n*       An element with the role=tree attribute\r\n*/\r\nvar TreeLinks = /** @class */ (function () {\r\n    function TreeLinks(node) {\r\n        // Check whether node is a DOM element\r\n        if (typeof node !== 'object') {\r\n            return;\r\n        }\r\n        this.domNode = node;\r\n        this.treeitems = [];\r\n    }\r\n    TreeLinks.prototype.init = function () {\r\n        function findTreeitems(node, tree, group, treeLevel) {\r\n            var elem = node.firstElementChild;\r\n            var ti = group;\r\n            while (elem) {\r\n                if ((elem.tagName.toLowerCase() === 'li' && elem.firstElementChild.tagName.toLowerCase() === 'span') ||\r\n                    elem.tagName.toLowerCase() === \"tr\" || (elem.tagName.toLowerCase() === 'th') || (elem.tagName.toLowerCase() === 'td')) {\r\n                    if (group && group.label.substring(0, 9) === \"Grid view\") {\r\n                        ti = new _TreeItemLinks__WEBPACK_IMPORTED_MODULE_0__.GridTreeItemLink(elem, tree, group, treeLevel);\r\n                    }\r\n                    else {\r\n                        ti = new _TreeItemLinks__WEBPACK_IMPORTED_MODULE_0__.TreeItemLink(elem, tree, group, treeLevel);\r\n                    }\r\n                    ti.init();\r\n                    if (group)\r\n                        group.children.push(ti);\r\n                    tree.treeitems.push(ti);\r\n                }\r\n                if (elem.firstElementChild) {\r\n                    findTreeitems(elem, tree, ti, treeLevel + 1);\r\n                }\r\n                elem = elem.nextElementSibling;\r\n            }\r\n        }\r\n        // initialize pop up menus\r\n        if (!this.domNode.getAttribute('role')) {\r\n            this.domNode.setAttribute('role', 'tree');\r\n        }\r\n        findTreeitems(this.domNode, this, undefined, 0);\r\n        this.updateVisibleTreeitems();\r\n        this.firstTreeitem.domNode.tabIndex = 0;\r\n        this.currentNode = this.firstTreeitem;\r\n    };\r\n    TreeLinks.prototype.setFocusToItem = function (treeitem) {\r\n        this.currentNode.domNode.tabIndex = 0;\r\n        this.currentNode = treeitem;\r\n        this.currentNode.domNode.focus();\r\n    };\r\n    TreeLinks.prototype.setFocusToAdjacentItem = function (treeitem) {\r\n        this.currentNode.domNode.tabIndex = 0;\r\n        var parent = this.currentNode.parent;\r\n        while (parent !== undefined) {\r\n            parent.domNode.setAttribute('aria-expanded', false);\r\n            this.updateVisibleTreeitems();\r\n            parent = parent.parent;\r\n        }\r\n        if (!treeitem.isVisible) {\r\n            var node = treeitem;\r\n            while (!treeitem.isVisible) {\r\n                this.expandTreeitem(node.parent);\r\n                node = node.parent;\r\n            }\r\n        }\r\n        this.currentNode = treeitem;\r\n        this.currentNode.domNode.focus();\r\n    };\r\n    TreeLinks.prototype.setFocusToNextItem = function () {\r\n        if (this.currentNode.parent) {\r\n            var nodeIndex = this.currentNode.parent.children.indexOf(this.currentNode);\r\n            if (nodeIndex < this.currentNode.parent.children.length - 1) {\r\n                this.setFocusToItem(this.currentNode.parent.children[nodeIndex + 1]);\r\n            }\r\n        }\r\n    };\r\n    TreeLinks.prototype.setFocusToNextLaver = function () {\r\n        if (this.currentNode.lastVisitedChild !== null) {\r\n            this.setFocusToItem(this.currentNode.lastVisitedChild);\r\n        }\r\n        else {\r\n            this.setFocusToItem(this.currentNode.children[0]);\r\n        }\r\n    };\r\n    TreeLinks.prototype.setFocusToPreviousItem = function () {\r\n        if (this.currentNode.parent) {\r\n            var nodeIndex = this.currentNode.parent.children.indexOf(this.currentNode);\r\n            if (nodeIndex > 0) {\r\n                this.setFocusToItem(this.currentNode.parent.children[nodeIndex - 1]);\r\n            }\r\n        }\r\n    };\r\n    TreeLinks.prototype.setFocusToParentItem = function () {\r\n        if (this.currentNode.parent) {\r\n            this.currentNode.parent.lastVisitedChild = this.currentNode;\r\n            this.setFocusToItem(this.currentNode.parent);\r\n            if (this.currentNode.isExpandable && this.currentNode.isExpanded())\r\n                this.collapseTreeitem(this.currentNode);\r\n        }\r\n    };\r\n    TreeLinks.prototype.setFocusToFirstItem = function () {\r\n        this.setFocusToItem(this.firstTreeitem);\r\n    };\r\n    TreeLinks.prototype.setFocusToLastItem = function () {\r\n        this.setFocusToItem(this.lastTreeitem);\r\n    };\r\n    TreeLinks.prototype.expandTreeitem = function (currentItem) {\r\n        if (currentItem.isExpandable) {\r\n            currentItem.domNode.setAttribute('aria-expanded', true);\r\n            this.updateVisibleTreeitems();\r\n        }\r\n    };\r\n    TreeLinks.prototype.expandAllSiblingItems = function (currentItem) {\r\n        for (var i = 0; i < this.treeitems.length; i++) {\r\n            var ti = this.treeitems[i];\r\n            if ((ti.parent === currentItem.parent) && ti.isExpandable) {\r\n                this.expandTreeitem(ti);\r\n            }\r\n        }\r\n    };\r\n    TreeLinks.prototype.collapseTreeitem = function (item) {\r\n        var parent;\r\n        if (item.isExpanded()) {\r\n            parent = this.currentNode;\r\n        }\r\n        else {\r\n            parent = this.currentNode.parent;\r\n        }\r\n        if (parent) {\r\n            parent.domNode.setAttribute('aria-expanded', false);\r\n            this.updateVisibleTreeitems();\r\n            this.setFocusToItem(parent);\r\n        }\r\n    };\r\n    TreeLinks.prototype.updateVisibleTreeitems = function () {\r\n        this.firstTreeitem = this.treeitems[0];\r\n        for (var i = 0; i < this.treeitems.length; i++) {\r\n            var ti = this.treeitems[i];\r\n            var parent_1 = ti.domNode.parentNode;\r\n            ti.isVisible = true;\r\n            while (parent_1 && (parent_1 !== this.domNode)) {\r\n                if (parent_1.getAttribute('aria-expanded') == 'false') {\r\n                    ti.isVisible = false;\r\n                }\r\n                parent_1 = parent_1.parentNode;\r\n            }\r\n            if (ti.isVisible) {\r\n                this.lastTreeitem = ti;\r\n            }\r\n        }\r\n    };\r\n    TreeLinks.prototype.focusOnSpecificNode = function (searchStr, base, visitedNodes) {\r\n        var _this = this;\r\n        var visited = visitedNodes ? visitedNodes : [];\r\n        if (!visited.includes(base)) {\r\n            visited.push(base);\r\n            if (base.label.split(\" \")[0].toLowerCase() === searchStr) {\r\n                var expandParents_1 = function (node) {\r\n                    if (node) {\r\n                        if (!node.isExpanded()) {\r\n                            _this.expandTreeitem(node);\r\n                            expandParents_1(node.parent);\r\n                        }\r\n                    }\r\n                };\r\n                var collapseChildren = function (node) {\r\n                    if (base !== node) {\r\n                        node.parent.lastVisitedChild = node;\r\n                        _this.currentNode = node.parent;\r\n                        _this.collapseTreeitem(_this.currentNode);\r\n                    }\r\n                };\r\n                expandParents_1(base.parent);\r\n                if (base.isExpanded()) {\r\n                    collapseChildren(this.currentNode);\r\n                    base.lastVisitedChild = this.currentNode;\r\n                    this.collapseTreeitem(this.currentNode);\r\n                }\r\n                this.setFocusToItem(base);\r\n            }\r\n            else {\r\n                if (base.parent) {\r\n                    this.focusOnSpecificNode(searchStr, base.parent, visited);\r\n                }\r\n                base.children.forEach(function (child) {\r\n                    return _this.focusOnSpecificNode(searchStr, child, visited);\r\n                });\r\n            }\r\n        }\r\n    };\r\n    return TreeLinks;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://olli-core/./src/Render/TreeView/TreeLink.ts?");

/***/ }),

/***/ "./src/Render/TreeView/TreeStyle.ts":
/*!******************************************!*\
  !*** ./src/Render/TreeView/TreeStyle.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"treeStyle\": () => (/* binding */ treeStyle)\n/* harmony export */ });\nvar treeStyle = \"ul[role=\\\"tree\\\"] {\\n    margin: 0;\\n    padding: 0;\\n    list-style: none;\\n  }\\n  \\n  ul[role=\\\"tree\\\"] li {\\n    margin: 0;\\n    padding: 0;\\n    list-style: none;\\n  }\\n  \\n  ul[role=\\\"tree\\\"] a {\\n    text-decoration: underline;\\n    border-color: transparent;\\n  }\\n  \\n  [role=\\\"treeitem\\\"] ul {\\n    margin: 0;\\n    padding: 0;\\n    margin-left: 0.9em;\\n  }\\n  \\n  [role=\\\"treeitem\\\"][aria-expanded=\\\"false\\\"] > ul {\\n    display: none;\\n  }\\n  \\n  [role=\\\"treeitem\\\"][aria-expanded=\\\"true\\\"] > ul {\\n    display: block;\\n  }\\n  \\n  [role=\\\"treeitem\\\"][aria-expanded=\\\"false\\\"] > span::before {\\n    position: relative;\\n    left: -0.25em;\\n  }\\n  \\n  [role=\\\"treeitem\\\"][aria-expanded=\\\"true\\\"] > span::before {\\n    position: relative;\\n    left: -0.25em;\\n  }\\n  \\n  /* [role=\\\"treeitem\\\"], */\\n  [role=\\\"treeitem\\\"] span {\\n    width: 16em;\\n    margin: 0;\\n    padding: 0.125em;\\n    border: 2px transparent solid;\\n    display: block;\\n  }\\n  \\n  /* disable default keyboard focus styling for treeitems\\n     Keyboard focus is styled with the following CSS */\\n  [role=\\\"treeitem\\\"]:focus {\\n    outline: 0;\\n  }\\n  \\n  [role=\\\"treeitem\\\"].focus,\\n  [role=\\\"treeitem\\\"] span.focus {\\n    border-color: black;\\n    background-color: #ddd;\\n  }\\n  \\n  [role=\\\"treeitem\\\"].hover,\\n  [role=\\\"treeitem\\\"] span.hover {\\n    background-color: #ddd;\\n  }\";\r\n\n\n//# sourceURL=webpack://olli-core/./src/Render/TreeView/TreeStyle.ts?");

/***/ }),

/***/ "./src/Render/TreeView/index.ts":
/*!**************************************!*\
  !*** ./src/Render/TreeView/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderTree\": () => (/* binding */ renderTree)\n/* harmony export */ });\n/* harmony import */ var _TreeStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeStyle */ \"./src/Render/TreeView/TreeStyle.ts\");\n\r\n// /**\r\n//  *\r\n//  * @param tree A {@link AccessibilityTreeNode} to generate a navigable tree view from\r\n//  * @returns An {@link HTMLElement} ARIA TreeView of the navigable tree view for a visualization\r\n//  */\r\n// export function renderTree(tree: AccessibilityTreeNode): HTMLElement {\r\n//     let nodeToAppend: HTMLElement = document.createElement(\"li\")\r\n//     nodeToAppend.setAttribute(\"role\", \"treeitem\");\r\n//     nodeToAppend.setAttribute(\"aria-expanded\", \"false\");\r\n//     const nestedChildElements: HTMLElement = document.createElement(\"ul\")\r\n//     const nodeDescription: HTMLElement = document.createElement(\"span\");\r\n//     nodeDescription.appendChild(document.createTextNode(tree.description));\r\n//     const treeChildren: AccessibilityTreeNode[] = tree.children;\r\n//     const dataChildren: AccessibilityTreeNode[] = treeChildren.filter((child: AccessibilityTreeNode) => child.type === \"data\")\r\n//     if (dataChildren.length > 0) {\r\n//         const table: HTMLElement = document.createElement(\"table\");\r\n//         const tableBody = document.createElement(\"tbody\");\r\n//         const rowHeaders = document.createElement(\"tr\");\r\n//         tree.fieldsUsed.forEach((key: string) => {\r\n//             const header = document.createElement(\"th\")\r\n//             header.setAttribute(\"class\", \"tableInformation\");\r\n//             header.innerText = key\r\n//             rowHeaders.appendChild(header);\r\n//         })\r\n//         tableBody.appendChild(rowHeaders)\r\n//         dataChildren.forEach((dataPoint: AccessibilityTreeNode) => {\r\n//             const dataRow = document.createElement(\"tr\")\r\n//             tree.fieldsUsed.forEach((key: string) => {\r\n//                 const headerData = document.createElement(\"td\")\r\n//                 headerData.setAttribute(\"class\", \"tableInformation\");\r\n//                 const value = dataPoint.selected[0][key];\r\n//                 if (!isNaN(value) && value % 1 != 0) {\r\n//                     headerData.innerText = Number(value).toFixed(2);\r\n//                 } else {\r\n//                     headerData.innerText = dataPoint.selected[0][key]\r\n//                 }\r\n//                 dataRow.appendChild(headerData);\r\n//             })\r\n//             tableBody.appendChild(dataRow)\r\n//         })\r\n//         table.appendChild(tableBody);\r\n//         nestedChildElements.appendChild(table);\r\n//     }\r\n//     nodeToAppend.appendChild(nodeDescription);\r\n//     if (treeChildren.length > 0) {\r\n//         treeChildren.filter((child: AccessibilityTreeNode) => child.type !== `data`).forEach((child: AccessibilityTreeNode) => {\r\n//             nestedChildElements.appendChild(renderTree(child));\r\n//         })\r\n//         nodeToAppend.appendChild(nestedChildElements);\r\n//     }\r\n//     const style = document.createElement('style')\r\n//     style.innerHTML = treeStyle;\r\n//     document.head.appendChild(style)\r\n//     return nodeToAppend;\r\n// }\r\n/**\r\n *\r\n * @param tree A {@link AccessibilityTreeNode} to generate a navigable tree view from\r\n * @returns An {@link HTMLElement} ARIA TreeView of the navigable tree view for a visualization\r\n */\r\nfunction renderTree(tree) {\r\n    var treeDom = document.createElement(\"ul\");\r\n    treeDom.appendChild(renderInnerTree(tree));\r\n    return treeDom;\r\n}\r\nfunction renderInnerTree(tree) {\r\n    var nodeToAppend = document.createElement(\"li\");\r\n    nodeToAppend.setAttribute(\"role\", \"treeitem\");\r\n    nodeToAppend.setAttribute(\"aria-expanded\", \"false\");\r\n    var nestedChildElements = document.createElement(\"ul\");\r\n    var nodeDescription = document.createElement(\"span\");\r\n    nodeDescription.appendChild(document.createTextNode(tree.description));\r\n    var treeChildren = tree.children;\r\n    var dataChildren = treeChildren.filter(function (child) { return child.type === \"data\"; });\r\n    if (dataChildren.length > 0) {\r\n        var table = document.createElement(\"table\");\r\n        var tableBody_1 = document.createElement(\"tbody\");\r\n        var rowHeaders_1 = document.createElement(\"tr\");\r\n        tree.fieldsUsed.forEach(function (key) {\r\n            var header = document.createElement(\"th\");\r\n            header.setAttribute(\"class\", \"tableInformation\");\r\n            header.innerText = key;\r\n            rowHeaders_1.appendChild(header);\r\n        });\r\n        tableBody_1.appendChild(rowHeaders_1);\r\n        dataChildren.forEach(function (dataPoint) {\r\n            var dataRow = document.createElement(\"tr\");\r\n            tree.fieldsUsed.forEach(function (key) {\r\n                var headerData = document.createElement(\"td\");\r\n                headerData.setAttribute(\"class\", \"tableInformation\");\r\n                var value = dataPoint.selected[0][key];\r\n                if (!isNaN(value) && value % 1 != 0) {\r\n                    headerData.innerText = Number(value).toFixed(2);\r\n                }\r\n                else {\r\n                    headerData.innerText = dataPoint.selected[0][key];\r\n                }\r\n                dataRow.appendChild(headerData);\r\n            });\r\n            tableBody_1.appendChild(dataRow);\r\n        });\r\n        table.appendChild(tableBody_1);\r\n        nestedChildElements.appendChild(table);\r\n    }\r\n    nodeToAppend.appendChild(nodeDescription);\r\n    if (treeChildren.length > 0) {\r\n        treeChildren.filter(function (child) { return child.type !== \"data\"; }).forEach(function (child) {\r\n            nestedChildElements.appendChild(renderTree(child));\r\n        });\r\n        nodeToAppend.appendChild(nestedChildElements);\r\n    }\r\n    var style = document.createElement('style');\r\n    style.innerHTML = _TreeStyle__WEBPACK_IMPORTED_MODULE_0__.treeStyle;\r\n    document.head.appendChild(style);\r\n    return nodeToAppend;\r\n}\r\n\n\n//# sourceURL=webpack://olli-core/./src/Render/TreeView/index.ts?");

/***/ }),

/***/ "./src/Structure/index.ts":
/*!********************************!*\
  !*** ./src/Structure/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"olliVisSpecToTree\": () => (/* binding */ olliVisSpecToTree)\n/* harmony export */ });\n/**\r\n * Constructs an {@link AccessibilityTreeNode} based off of a generalized visualization\r\n * @param olliVisSpec the {@link Chart} or {@link CompositeChart} to transform into a tree\r\n * @returns The transormed {@link AccessibilityTreeNode}\r\n */\r\nfunction olliVisSpecToTree(olliVisSpec) {\r\n    var node;\r\n    if (olliVisSpec.type === \"facetedChart\") {\r\n        var facets_1 = olliVisSpec;\r\n        facets_1.charts.forEach(function (chart, k) {\r\n            chart.data = chart.data.filter(function (val) { return val[facets_1.facetedField] === k; });\r\n            var updateNestedData = (function (g) { return g.data = JSON.parse(JSON.stringify(chart.data)); });\r\n            chart.axes.forEach(updateNestedData);\r\n            chart.legends.forEach(updateNestedData);\r\n        });\r\n        node = informationToNode(olliVisSpec.description, null, olliVisSpec.data, \"multiView\", olliVisSpec);\r\n        node.description += \" with \".concat(node.children.length, \" nested charts\");\r\n    }\r\n    else {\r\n        var axesString = olliVisSpec.axes.length > 0 ?\r\n            olliVisSpec.axes.length == 2 ?\r\n                \" \".concat(olliVisSpec.axes.length, \" axes\") :\r\n                \" \".concat(olliVisSpec.axes[0].orient, \" axis\") :\r\n            '';\r\n        var legendsString = olliVisSpec.legends.length === 1 ? \" and \".concat(olliVisSpec.legends.length, \" legend\") : '';\r\n        node = informationToNode(olliVisSpec.description, null, olliVisSpec.data, \"chart\", olliVisSpec);\r\n        node.description += \" with \".concat(axesString, \" \").concat(legendsString);\r\n    }\r\n    return node;\r\n}\r\n/**\r\n * Generates children tree nodes for the given parent node.\r\n * @param parent The root faceted chart to be the parent of each nested chart\r\n * @param multiViewChart The {@link FacetedChart} of the abstracted visualization\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateMultiViewChildren(parent, multiViewChart) {\r\n    multiViewChart.type === \"facetedChart\";\r\n    var charts = [];\r\n    multiViewChart.charts.forEach(function (c, k, m) {\r\n        charts.push(informationToNode(\"A facet titled \".concat(k, \", \").concat(charts.length + 1, \" of \").concat(m.size), parent, multiViewChart.data, \"chart\", c));\r\n    });\r\n    return charts;\r\n}\r\n/**\r\n * Recursively generates children nodes of a chart's structured elements for the provided parent\r\n * @param childrenNodes the array of children nodes to eventually return to the parent\r\n * @param parent The root chart to be the parent of each nested chart\r\n * @param axes The {@link Guide}s of axes to be transformed into {@link AccessibilityTreeNode}s\r\n * @param legends The {@link Guide}s of legends to be transformed into {@link AccessibilityTreeNode}s\r\n * @param grids The {@link Guide}s of axes with grid lines to be transformed into {@link AccessibilityTreeNode}s\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateChartChildren(childrenNodes, parent, axes, legends, grids) {\r\n    if (axes.length > 0) {\r\n        var axis = axes.pop();\r\n        var scaleStr = axis.scaleType ? \"for a \".concat(axis.scaleType, \" scale \") : \"\";\r\n        var axisField_1 = Array.isArray(axis.field) ? axis.field[1] : axis.field;\r\n        var defaultRange = axis.data[0][axisField_1];\r\n        // TODO: Re-used code from line 143. Make utility function and add try/catch since the data should not be undefined!\r\n        if (defaultRange === undefined) {\r\n            var updatedField = Object.keys(axis.data[0]).find(function (k) { return k.includes(axisField_1) || axisField_1.includes(k); });\r\n            if (updatedField) {\r\n                axisField_1 = updatedField;\r\n                defaultRange = axis.data[0][axisField_1];\r\n            }\r\n        }\r\n        var minValue = axis.data.reduce(function (min, val) {\r\n            if (val[axisField_1] !== null && val[axisField_1] < min)\r\n                return val[axisField_1];\r\n            return min;\r\n        }, axis.data[0][axisField_1]);\r\n        var maxValue = axis.data.reduce(function (max, val) {\r\n            if (val[axisField_1] !== null && val[axisField_1] > max)\r\n                return val[axisField_1];\r\n            return max;\r\n        }, axis.data[0][axisField_1]);\r\n        if (axisField_1.toLowerCase().includes(\"date\")) {\r\n            minValue = new Date(minValue).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' });\r\n            maxValue = new Date(maxValue).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' });\r\n        }\r\n        var description = \"\".concat(axis.title, \" \").concat(scaleStr, \"with values from \").concat(minValue, \" to \").concat(maxValue);\r\n        childrenNodes.push(informationToNode(description, parent, axis.data, axis.title.includes(\"Y-Axis\") ? \"yAxis\" : \"xAxis\", axis));\r\n        return generateChartChildren(childrenNodes, parent, axes, legends, grids);\r\n    }\r\n    else if (legends.length > 0) {\r\n        var legend = legends.pop();\r\n        var scaleType = legend.scaleType ? \"for \".concat(legend.scaleType, \" scale \") : \"\";\r\n        var node = informationToNode(legend.title, parent, legend.data, \"legend\", legend);\r\n        node.description = \"Legend titled '\".concat(node.description, \"' \").concat(scaleType, \"with \").concat(node.children.length, \" values\");\r\n        childrenNodes.push(node);\r\n        return generateChartChildren(childrenNodes, parent, axes, legends, grids);\r\n    }\r\n    else if (grids.length > 0 && grids.length === 2) {\r\n        var grid = [grids.pop(), grids.pop()];\r\n        childrenNodes.push(informationToNode(\"Grid view of the data\", parent, grid[0].data, \"grid\", grid));\r\n        return generateChartChildren(childrenNodes, parent, axes, legends, grids);\r\n    }\r\n    else {\r\n        return childrenNodes;\r\n    }\r\n}\r\n/**\r\n * Generates the incremental children for each structured element of a visualization\r\n * @param parent The structured element whose data is being incrmeented\r\n * @param field The data field used to compare idividual data points\r\n * @param values The groupings or increments of values for the structured element (ex: for axes these are the array of ticks)\r\n * @param data The array of data used in the visualization\r\n * @param markUsed {@link Mark} of the visualization\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateStructuredNodeChildren(parent, field, values, data, markUsed) {\r\n    var lowerCaseDesc = parent.description.toLowerCase();\r\n    if (isStringArray(values) && !field.includes(\"date\") || parent.type === \"legend\") {\r\n        return values.map(function (grouping) {\r\n            return informationToNode(\"\".concat([[grouping]]), parent, data.filter(function (node) { return node[field] === grouping; }), \"filteredData\", data.filter(function (node) { return node[field] === grouping; }));\r\n        });\r\n    }\r\n    else {\r\n        var ticks = values;\r\n        var filterData_1 = function (lowerBound, upperBound) {\r\n            return data.filter(function (val) {\r\n                if ((lowerCaseDesc.includes(\"date\") || lowerCaseDesc.includes(\"temporal\")) && upperBound.toString().length === 4) {\r\n                    var d = new Date(val[field]);\r\n                    return d.getFullYear() >= lowerBound && d.getFullYear() < upperBound;\r\n                }\r\n                else if (val[field] === undefined) {\r\n                    var updatedField = Object.keys(val).find(function (k) { return k.includes(field) || field.includes(k); });\r\n                    if (updatedField)\r\n                        return val[updatedField] >= lowerBound && val[updatedField] < upperBound;\r\n                }\r\n                return val[field] >= lowerBound && val[field] < upperBound;\r\n            });\r\n        };\r\n        var valueIncrements = void 0;\r\n        if (markUsed !== 'bar') {\r\n            valueIncrements = ticks.reduce(getEncodingValueIncrements, []);\r\n        }\r\n        else {\r\n            if (lowerCaseDesc.includes(\"date\") || field.includes(\"date\")) {\r\n                valueIncrements = ticks.reduce(getEncodingValueIncrements, []);\r\n            }\r\n            else {\r\n                valueIncrements = ticks.map(function (val) { return [val, val]; });\r\n            }\r\n        }\r\n        return valueIncrements.map(function (range) {\r\n            var desc = \"\";\r\n            if ((lowerCaseDesc.includes(\"date\") || field.includes(\"date\") || parent.description.includes(\"temporal\")) && range[0].toString().length > 4) {\r\n                range.forEach(function (val) { return desc += \"\".concat(new Date(val).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' }), \", \"); });\r\n            }\r\n            else {\r\n                desc = \"\".concat(range, \",\");\r\n            }\r\n            return informationToNode(desc, parent, filterData_1(range[0], range[1]), \"filteredData\", filterData_1(range[0], range[1]));\r\n        });\r\n    }\r\n}\r\n/**\r\n * Generates the incremental children for a pair of axes forming an explorable grid\r\n * @param parent The structured element whose data is being incrmeented\r\n * @param field The data fields used to compare idividual data points\r\n * @param firstValues Array of tick values for the first axis\r\n * @param secondValues Array of tick values for the second axis\r\n * @param data The array of data used in the visualization\r\n * @returns an array of {@link AccessibilityTreeNode} to be the given parent's children\r\n */\r\nfunction generateGridChildren(parent, fields, firstValues, secondValues, data) {\r\n    var childNodes = [];\r\n    var filterData = function (xLowerBound, yLowerBound, xUpperBound, yUpperBound) {\r\n        return data.filter(function (val) {\r\n            var inRange = function (field, r1, r2) {\r\n                if (r2) {\r\n                    return val[field] >= r1 && val[field] < r2;\r\n                }\r\n                else {\r\n                    return val[field] === r1;\r\n                }\r\n            };\r\n            return inRange(fields[1], xLowerBound, xUpperBound) && inRange(fields[0], yLowerBound, yUpperBound);\r\n        });\r\n    };\r\n    var yIncrements = firstValues.reduce(getEncodingValueIncrements, []);\r\n    var xIncrements = secondValues.reduce(getEncodingValueIncrements, []);\r\n    yIncrements.forEach(function (yIncrement) {\r\n        xIncrements.forEach(function (xIncrement) {\r\n            var filteredSelection = filterData(xIncrement[0], yIncrement[0], xIncrement[1], yIncrement[1]);\r\n            childNodes.push(informationToNode(\"\".concat([yIncrement, xIncrement]), parent, filteredSelection, \"filteredData\", filteredSelection));\r\n        });\r\n    });\r\n    return childNodes;\r\n}\r\nfunction isStringArray(data) {\r\n    return data.every(function (pnt) { return typeof pnt === \"string\"; });\r\n}\r\nfunction getEncodingValueIncrements(incrementArray, currentValue, index, array) {\r\n    if (isStringArray(array)) {\r\n        incrementArray.push([currentValue]);\r\n        return incrementArray;\r\n    }\r\n    else {\r\n        var bounds = void 0;\r\n        var reducedIndex = index - 1;\r\n        if (reducedIndex === -1 && currentValue !== 0) {\r\n            var incrementDifference = array[index + 1] - currentValue;\r\n            bounds = [(currentValue - incrementDifference), currentValue];\r\n        }\r\n        else if (index === array.length - 1) {\r\n            var incrementDifference = currentValue - array[index - 1];\r\n            var finalIncrement = void 0;\r\n            if (currentValue instanceof Date) {\r\n                finalIncrement = currentValue.getTime() + incrementDifference;\r\n            }\r\n            else {\r\n                finalIncrement = currentValue + incrementDifference;\r\n            }\r\n            incrementArray.push([array[reducedIndex], currentValue]);\r\n            bounds = [currentValue, finalIncrement];\r\n        }\r\n        else {\r\n            bounds = [array[reducedIndex], array[reducedIndex + 1]];\r\n        }\r\n        incrementArray.push([bounds[0], bounds[1]]);\r\n        return incrementArray;\r\n    }\r\n}\r\n/**\r\n * Recursively generates a child node for each data point in the provided range\r\n * @param childrenNodes The array {@link AccessibilityTreeNode} to eventually return\r\n * @param filteredSelection The data points to transform into {@link AccessibilityTreeNode} nodes\r\n * @param parent The parent whose children are being generated\r\n * @returns\r\n */\r\nfunction generateFilteredDataChildren(childrenNodes, filteredSelection, parent) {\r\n    if (filteredSelection.length > 0) {\r\n        // const dataPoint: any = filteredSelection.pop();\r\n        var dataPoint_1 = filteredSelection.pop();\r\n        var objCopy_1 = {};\r\n        Object.keys(dataPoint_1).forEach(function (key) {\r\n            if (key.toLowerCase().includes(\"date\")) {\r\n                objCopy_1[key] = new Date(dataPoint_1[key]).toLocaleString(\"en-US\", { year: 'numeric', month: 'short', day: 'numeric' });\r\n            }\r\n            else {\r\n                objCopy_1[key] = dataPoint_1[key];\r\n            }\r\n        });\r\n        childrenNodes.push(informationToNode(nodeToDesc(dataPoint_1), parent, [objCopy_1], \"data\"));\r\n        generateFilteredDataChildren(childrenNodes, filteredSelection, parent);\r\n    }\r\n    return childrenNodes;\r\n}\r\n/**\r\n * Creates specific children nodes based on a provided {@link NodeType}\r\n * @param type The {@link NodeType} of the parent\r\n * @param parent The parent {@link AccessibilityTreeNode} whose children need to be generated\r\n * @param generationInformation A changing variable that assists in generating children nodes at all levels\r\n * @returns an array of {@link AccessibilityTreeNode}\r\n */\r\nfunction generateChildNodes(type, parent, generationInformation) {\r\n    if (type === \"multiView\") {\r\n        return generateMultiViewChildren(parent, generationInformation);\r\n    }\r\n    else if (type === \"chart\") {\r\n        return generateChartChildren([], parent, generationInformation.axes, generationInformation.legends, generationInformation.gridNodes);\r\n    }\r\n    else if (type === \"xAxis\" || type === \"yAxis\" || type === \"legend\") {\r\n        return generateStructuredNodeChildren(parent, generationInformation.field, generationInformation.values, generationInformation.data, generationInformation.markUsed);\r\n    }\r\n    else if (type === \"filteredData\") {\r\n        return generateFilteredDataChildren([], generationInformation.map(function (val) { return Object.assign({}, val); }), parent);\r\n    }\r\n    else if (type === \"grid\") {\r\n        return generateGridChildren(parent, [generationInformation[0].field, generationInformation[1].field], generationInformation[0].values, generationInformation[1].values, generationInformation[0].data);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Creates a {@link AccessibilityTreeNode} of the given parameters\r\n * @param desc The string that will be used when rendering this node\r\n * @param parent The parent {@link AccessibilityTreeNode} of the node to be generated\r\n * @param selected Selection of data from this node and its children\r\n * @param type Meta-data to know what kind of element this node is from a visualization\r\n * @param childrenInformation changing variable to assist with generating more nodes of the tree\r\n * @returns The {@link AccessibilityTreeNode} from the provided parameters\r\n */\r\nfunction informationToNode(desc, parent, selected, type, childrenInformation) {\r\n    var node = {\r\n        description: desc,\r\n        parent: parent,\r\n        children: [],\r\n        selected: selected,\r\n        type: type,\r\n        fieldsUsed: parent !== null ? parent.fieldsUsed : childrenInformation.dataFieldsUsed\r\n    };\r\n    if (childrenInformation)\r\n        node.children = generateChildNodes(type, node, childrenInformation);\r\n    node.description = nodeToDesc(node);\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param node The node whose description is being created\r\n * @returns A description based on the provided {@link AccessibilityTreeNode}\r\n */\r\nfunction nodeToDesc(node) {\r\n    if (node.type === \"multiView\" || node.type === \"chart\") {\r\n        return node.description;\r\n    }\r\n    else if (node.type === \"xAxis\" || node.type === \"yAxis\") {\r\n        return node.description;\r\n    }\r\n    else if (node.type === \"legend\") {\r\n        return node.description;\r\n    }\r\n    else if (node.type === \"filteredData\") {\r\n        return \"Range \".concat(node.description, \" \").concat(node.selected.length, \" values in the interval\");\r\n    }\r\n    else if (node.type === \"grid\") {\r\n        return node.description;\r\n    }\r\n    else if (node.type === 'data') {\r\n        return node.fieldsUsed.reduce(function (desc, currentKey) { return \"\".concat(desc, \" \").concat(currentKey, \": \").concat(node.selected[0][currentKey]); }, \"\");\r\n    }\r\n    return \"\";\r\n}\r\n\n\n//# sourceURL=webpack://olli-core/./src/Structure/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"olli\": () => (/* binding */ olli)\n/* harmony export */ });\n/* harmony import */ var _Render_Table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render/Table */ \"./src/Render/Table/index.ts\");\n/* harmony import */ var _Render_TreeView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Render/TreeView */ \"./src/Render/TreeView/index.ts\");\n/* harmony import */ var _Render_TreeView_TreeLink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Render/TreeView/TreeLink */ \"./src/Render/TreeView/TreeLink.ts\");\n/* harmony import */ var _Structure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Structure */ \"./src/Structure/index.ts\");\n\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param config The {@link OlliConfigOptions} object to specify how an accessible visualization should be generated.\r\n */\r\nfunction olli(olliVisSpec, config) {\r\n    var chartEncodingTree = (0,_Structure__WEBPACK_IMPORTED_MODULE_3__.olliVisSpecToTree)(olliVisSpec);\r\n    var htmlRendering;\r\n    if (config) {\r\n        switch (config.renderType) {\r\n            case (\"table\"):\r\n                htmlRendering = (0,_Render_Table__WEBPACK_IMPORTED_MODULE_0__.renderTable)(chartEncodingTree);\r\n                break;\r\n            case ('tree'):\r\n            default:\r\n                htmlRendering = document.createElement(\"ul\").appendChild((0,_Render_TreeView__WEBPACK_IMPORTED_MODULE_1__.renderTree)(chartEncodingTree));\r\n                new _Render_TreeView_TreeLink__WEBPACK_IMPORTED_MODULE_2__.TreeLinks(htmlRendering).init();\r\n        }\r\n        if (config.ariaLabel) {\r\n            htmlRendering.setAttribute(\"aria-label\", config.ariaLabel);\r\n        }\r\n    }\r\n    else {\r\n        htmlRendering = document.createElement(\"ul\").appendChild((0,_Render_TreeView__WEBPACK_IMPORTED_MODULE_1__.renderTree)(chartEncodingTree));\r\n        new _Render_TreeView_TreeLink__WEBPACK_IMPORTED_MODULE_2__.TreeLinks(htmlRendering).init();\r\n    }\r\n    document.addEventListener('keypress', function (keyStroke) {\r\n        if (keyStroke.key.toLowerCase() === 't') {\r\n            var treeview = document.getElementById('treeView');\r\n            if (treeview !== null) {\r\n                treeview.firstChild.focus();\r\n            }\r\n        }\r\n    });\r\n    return htmlRendering;\r\n}\r\n\n\n//# sourceURL=webpack://olli-core/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});